{"file_contents":{"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/User.kt":{"content":"package com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(\n    tableName = \"users\",\n    indices = [Index(value = [\"email\"], unique = true)]\n)\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val nom: String,\n    val email: String,\n    val telephone: String? = null,\n    val organisation: String? = null,\n    val role: String = \"Membre\",\n    val pin: String,\n    val createdAt: Long = System.currentTimeMillis()\n)\n","size_bytes":525},"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/Payer.kt":{"content":"\npackage com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(\n    tableName = \"payers\",\n    foreignKeys = [\n        ForeignKey(\n            entity = Event::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"eventId\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(value = [\"eventId\"])]\n)\ndata class Payer(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val eventId: Long? = null, // Nullable pour les anciens payeurs non li√©s √† un √©v√©nement\n    val nom: String,\n    val contact: String? = null, // T√©l√©phone ou email\n    val note: String? = null,\n    val createdAt: Long = System.currentTimeMillis()\n)\n","size_bytes":790},"AndroidProjects/app/src/main/java/com/example/musep50/ui/adapter/OperationAdapter.kt":{"content":"package com.example.musep50.ui.adapter\n\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.DiffUtil\nimport androidx.recyclerview.widget.ListAdapter\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.musep50.R\nimport com.example.musep50.data.entities.Operation\nimport com.example.musep50.databinding.ItemOperationBinding\nimport com.example.musep50.viewmodel.OperationStats\nimport java.text.NumberFormat\nimport java.util.Locale\n\nclass OperationAdapter(\n    private val onItemClick: (Operation) -> Unit\n) : ListAdapter<Operation, OperationAdapter.OperationViewHolder>(OperationDiffCallback()) {\n    \n    private var operationStats = mapOf<Long, OperationStats>()\n    \n    fun setOperationStats(stats: Map<Long, OperationStats>) {\n        operationStats = stats\n        notifyDataSetChanged()\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OperationViewHolder {\n        val binding = ItemOperationBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return OperationViewHolder(binding)\n    }\n    \n    override fun onBindViewHolder(holder: OperationViewHolder, position: Int) {\n        holder.bind(getItem(position), operationStats[getItem(position).id])\n    }\n    \n    inner class OperationViewHolder(\n        private val binding: ItemOperationBinding\n    ) : RecyclerView.ViewHolder(binding.root) {\n        \n        fun bind(operation: Operation, stats: OperationStats?) {\n            binding.operationName.text = operation.nom\n            binding.operationType.text = operation.type\n            binding.statusChip.text = operation.statut\n            \n            stats?.let {\n                val formatter = NumberFormat.getNumberInstance(Locale.FRANCE)\n                binding.montantCollecte.text = \"${formatter.format(it.montantCollecte)} FCFA\"\n                binding.montantRestant.text = \"${formatter.format(it.montantRestant)} FCFA\"\n                binding.nombrePayeurs.text = it.nombrePaiements.toString()\n                binding.progressBar.progress = it.pourcentage\n            } ?: run {\n                binding.montantCollecte.text = \"0 FCFA\"\n                binding.montantRestant.text = \"${NumberFormat.getNumberInstance(Locale.FRANCE).format(operation.montantCible)} FCFA\"\n                binding.nombrePayeurs.text = \"0\"\n                binding.progressBar.progress = 0\n            }\n            \n            binding.root.setOnClickListener {\n                onItemClick(operation)\n            }\n        }\n    }\n}\n\nclass OperationDiffCallback : DiffUtil.ItemCallback<Operation>() {\n    override fun areItemsTheSame(oldItem: Operation, newItem: Operation): Boolean {\n        return oldItem.id == newItem.id\n    }\n    \n    override fun areContentsTheSame(oldItem: Operation, newItem: Operation): Boolean {\n        return oldItem == newItem\n    }\n}\n","size_bytes":2932},"AndroidProjects/app/src/main/java/com/example/musep50/ui/RetardatairesActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport android.view.View\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Operation\nimport com.example.musep50.data.entities.User\nimport com.example.musep50.databinding.ActivityRetardatairesBinding\nimport com.example.musep50.ui.adapter.RetardataireAdapter\nimport com.example.musep50.viewmodel.DashboardViewModel\nimport com.example.musep50.viewmodel.PaiementViewModel\nimport kotlinx.coroutines.launch\nimport java.text.NumberFormat\nimport java.util.*\n\nclass RetardatairesActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityRetardatairesBinding\n    private val dashboardViewModel: DashboardViewModel by viewModels()\n    private val paiementViewModel: PaiementViewModel by viewModels()\n    private lateinit var adapter: RetardataireAdapter\n    private var currentOperation: Operation? = null\n    private var allUsers = listOf<User>()\n    private var retardataires = listOf<User>()\n    private var selectedRetardataires = listOf<User>()\n    private val formatter = NumberFormat.getNumberInstance(Locale.FRANCE)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityRetardatairesBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        val operationId = intent.getLongExtra(\"operation_id\", -1L)\n\n        setupToolbar()\n        setupRecyclerView()\n        setupButtons()\n        loadData(operationId)\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun setupRecyclerView() {\n        adapter = RetardataireAdapter(\n            onSelectionChanged = { selected ->\n                selectedRetardataires = selected\n                updateActionCard()\n            },\n            onSendIndividual = { user ->\n                sendReminderToUser(user)\n            }\n        )\n        binding.retardatairesRecyclerView.layoutManager = LinearLayoutManager(this)\n        binding.retardatairesRecyclerView.adapter = adapter\n    }\n\n    private fun setupButtons() {\n        binding.btnSelectAll.setOnClickListener {\n            if (selectedRetardataires.size == retardataires.size) {\n                adapter.clearSelection()\n            } else {\n                adapter.selectAll()\n            }\n        }\n\n        binding.btnSendReminders.setOnClickListener {\n            sendRemindersToSelected()\n        }\n    }\n\n    private fun loadData(operationId: Long) {\n        val database = AppDatabase.getDatabase(this)\n        val repository = Repository(database)\n\n        dashboardViewModel.allOperations.observe(this) { operations ->\n            currentOperation = operations.find { it.id == operationId }\n        }\n\n        repository.getAllUsers().observe(this) { users ->\n            allUsers = users\n            calculateRetardataires(operationId)\n        }\n\n        paiementViewModel.getPaiementsWithPayerByOperation(operationId).observe(this) { payments ->\n            val payerIds = payments.map { it.paiement.payerId }.toSet()\n            retardataires = allUsers.filter { !payerIds.contains(it.id) }\n            adapter.submitList(retardataires)\n            updateRetardatairesCount()\n        }\n    }\n\n    private fun calculateRetardataires(operationId: Long) {\n        paiementViewModel.getPaiementsWithPayerByOperation(operationId).observe(this) { payments ->\n            val payerIds = payments.map { it.paiement.payerId }.toSet()\n            retardataires = allUsers.filter { !payerIds.contains(it.id) }\n            adapter.submitList(retardataires)\n            updateRetardatairesCount()\n        }\n    }\n\n    private fun updateRetardatairesCount() {\n        val count = retardataires.size\n        binding.retardatairesCount.text = if (count > 0) {\n            \"$count membre${if (count > 1) \"s\" else \"\"} en attente\"\n        } else {\n            \"Tous les membres ont pay√© ! üéâ\"\n        }\n    }\n\n    private fun updateActionCard() {\n        val count = selectedRetardataires.size\n        if (count > 0) {\n            binding.actionCard.visibility = View.VISIBLE\n            binding.selectedCount.text = \"$count membre${if (count > 1) \"s\" else \"\"} s√©lectionn√©${if (count > 1) \"s\" else \"\"}\"\n            binding.btnSelectAll.text = \"Tout d√©s√©lectionner\"\n        } else {\n            binding.actionCard.visibility = View.GONE\n            binding.btnSelectAll.text = \"Tout s√©lectionner\"\n        }\n    }\n\n    private fun generateReminderMessage(user: User): String {\n        val operation = currentOperation ?: return \"\"\n        \n        val montant = lifecycleScope.launch {\n            val repository = Repository(AppDatabase.getDatabase(this@RetardatairesActivity))\n            val montantDu = operation.montantCible / allUsers.size\n            montantDu\n        }\n        \n        return \"\"\"\n            Bonjour ${user.nom},\n            \n            Nous n'avons pas encore re√ßu votre paiement pour l'op√©ration \"${operation.nom}\" (${operation.type}).\n            \n            üìÖ Date limite: √Ä confirmer\n            üí∞ Montant attendu: √Ä confirmer FCFA\n            \n            Merci de bien vouloir r√©gulariser votre situation dans les meilleurs d√©lais.\n            \n            Cordialement,\n            MUSEP50\n        \"\"\".trimIndent()\n    }\n\n    private fun sendReminderToUser(user: User) {\n        val message = generateReminderMessage(user)\n        shareOnWhatsApp(message, user.telephone)\n    }\n\n    private fun sendRemindersToSelected() {\n        if (selectedRetardataires.isEmpty()) return\n\n        if (selectedRetardataires.size == 1) {\n            sendReminderToUser(selectedRetardataires[0])\n        } else {\n            val messages = selectedRetardataires.joinToString(\"\\n\\n---\\n\\n\") { user ->\n                generateReminderMessage(user)\n            }\n            shareOnWhatsApp(messages, null)\n        }\n    }\n\n    private fun shareOnWhatsApp(message: String, phoneNumber: String?) {\n        try {\n            val sendIntent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_TEXT, message)\n                type = \"text/plain\"\n                \n                if (!phoneNumber.isNullOrBlank()) {\n                    val cleanNumber = phoneNumber.replace(Regex(\"[^0-9+]\"), \"\")\n                    val uri = Uri.parse(\"https://wa.me/$cleanNumber?text=${Uri.encode(message)}\")\n                    data = uri\n                    setPackage(\"com.whatsapp\")\n                } else {\n                    setPackage(\"com.whatsapp\")\n                }\n            }\n            startActivity(sendIntent)\n        } catch (e: Exception) {\n            val sendIntent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_TEXT, message)\n                type = \"text/plain\"\n            }\n            val shareIntent = Intent.createChooser(sendIntent, \"Envoyer rappel via\")\n            startActivity(shareIntent)\n        }\n    }\n}\n","size_bytes":7422},"AndroidProjects/app/src/main/java/com/example/musep50/MainActivity.kt":{"content":"\npackage com.example.musep50\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport android.widget.VideoView\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.musep50.databinding.ActivityMainBinding\nimport com.example.musep50.ui.DashboardActivity\nimport com.example.musep50.ui.LoginActivity\n\nclass MainActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityMainBinding\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Toujours afficher l'√©cran d'intro avec vid√©o √† chaque lancement\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        setupVideoView()\n        setupContinueButton()\n    }\n    \n    private fun setupVideoView() {\n        val videoUri = Uri.parse(\"android.resource://\" + packageName + \"/\" + R.raw.deo)\n        binding.videoView.setVideoURI(videoUri)\n        \n        // Lecture automatique en boucle\n        binding.videoView.setOnPreparedListener { mediaPlayer ->\n            mediaPlayer.isLooping = true\n            mediaPlayer.start()\n        }\n        \n        // D√©marrer la vid√©o\n        binding.videoView.start()\n    }\n    \n    private fun setupContinueButton() {\n        binding.btnContinue.setOnClickListener {\n            startActivity(Intent(this, LoginActivity::class.java))\n            finish()\n        }\n    }\n    \n    override fun onResume() {\n        super.onResume()\n        if (::binding.isInitialized) {\n            binding.videoView.start()\n        }\n    }\n    \n    override fun onPause() {\n        super.onPause()\n        if (::binding.isInitialized) {\n            binding.videoView.pause()\n        }\n    }\n}\n","size_bytes":1756},"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/Parametre.kt":{"content":"package com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(\n    tableName = \"parametres\",\n    indices = [Index(value = [\"cle\"], unique = true)]\n)\ndata class Parametre(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val cle: String,\n    val valeur: String,\n    val updatedAt: Long = System.currentTimeMillis()\n)\n","size_bytes":407},"AndroidProjects/app/src/main/java/com/example/musep50/ui/ProfileActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.content.Intent\nimport android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport com.example.musep50.databinding.ActivityProfileBinding\nimport com.example.musep50.viewmodel.AuthViewModel\nimport kotlinx.coroutines.launch\n\nclass ProfileActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityProfileBinding\n    private val viewModel: AuthViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityProfileBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        setupToolbar()\n        loadUserProfile()\n        setupButtons()\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun loadUserProfile() {\n        val sharedPreferences = getSharedPreferences(\"musep50_prefs\", MODE_PRIVATE)\n        val userId = sharedPreferences.getLong(\"current_user_id\", -1L)\n\n        viewModel.currentUser.observe(this) { user ->\n            user?.let {\n                binding.userName.text = it.nom\n                binding.userEmail.text = it.email\n            }\n        }\n\n        if (userId != -1L) {\n            viewModel.loadUserById(userId)\n        }\n    }\n\n    private fun setupButtons() {\n        binding.btnEditProfile.setOnClickListener {\n            // TODO: Open edit profile activity\n        }\n\n        binding.btnChangePin.setOnClickListener {\n            // TODO: Open change PIN dialog\n        }\n\n        binding.btnAbout.setOnClickListener {\n            // TODO: Show about dialog\n        }\n\n        binding.btnLogout.setOnClickListener {\n            val sharedPreferences = getSharedPreferences(\"musep50_prefs\", MODE_PRIVATE)\n            sharedPreferences.edit().clear().apply()\n\n            startActivity(Intent(this, LoginActivity::class.java))\n            finishAffinity()\n        }\n    }\n}","size_bytes":2159},"AndroidProjects/app/src/main/java/com/example/musep50/ui/OperationDetailsActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.widget.doOnTextChanged\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.musep50.data.dao.PaiementWithPayer\nimport com.example.musep50.data.entities.User\nimport com.example.musep50.databinding.ActivityOperationDetailsBinding\nimport com.example.musep50.ui.adapter.PaymentAdapter\nimport com.example.musep50.viewmodel.AuthViewModel\nimport com.example.musep50.viewmodel.DashboardViewModel\nimport com.example.musep50.viewmodel.PaiementViewModel\nimport java.text.NumberFormat\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nclass OperationDetailsActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityOperationDetailsBinding\n    private val dashboardViewModel: DashboardViewModel by viewModels()\n    private val paiementViewModel: PaiementViewModel by viewModels()\n    private val authViewModel: AuthViewModel by viewModels()\n    private lateinit var adapter: PaymentAdapter\n    private var allPayments = listOf<PaiementWithPayer>()\n    private var allUsers = listOf<User>()\n    private val dateFormat = SimpleDateFormat(\"d MMM yyyy\", Locale.FRANCE)\n    private val formatter = NumberFormat.getNumberInstance(Locale.FRANCE)\n    private var currentOperationId: Long = -1L\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityOperationDetailsBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        currentOperationId = intent.getLongExtra(\"operation_id\", -1L)\n\n        setupToolbar()\n        setupRecyclerView()\n        setupSearch()\n        setupFab()\n        observeViewModels()\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun setupRecyclerView() {\n        adapter = PaymentAdapter()\n        binding.paymentsRecyclerView.layoutManager = LinearLayoutManager(this)\n        binding.paymentsRecyclerView.adapter = adapter\n    }\n\n    private fun setupSearch() {\n        binding.searchInput.doOnTextChanged { text, _, _, _ ->\n            filterPayments(text.toString())\n        }\n    }\n\n    private fun setupFab() {\n        binding.fabAddPayment.setOnClickListener {\n            val dialog = AddPaymentDialog(operationId = currentOperationId) {\n                dashboardViewModel.loadOperationStats(listOf(currentOperationId))\n            }\n            dialog.show(supportFragmentManager, AddPaymentDialog.TAG)\n        }\n\n        binding.btnPublish.setOnClickListener {\n            val intent = android.content.Intent(this, PublishActivity::class.java)\n            intent.putExtra(\"operation_id\", currentOperationId)\n            startActivity(intent)\n        }\n\n        binding.btnRetardataires.setOnClickListener {\n            val intent = android.content.Intent(this, RetardatairesActivity::class.java)\n            intent.putExtra(\"operation_id\", currentOperationId)\n            startActivity(intent)\n        }\n    }\n\n    private fun filterPayments(query: String) {\n        val filtered = if (query.isBlank()) {\n            allPayments\n        } else {\n            allPayments.filter { payment ->\n                payment.payerName.contains(query, ignoreCase = true) ||\n                payment.paiement.methodePaiement.contains(query, ignoreCase = true)\n            }\n        }\n        adapter.submitList(filtered)\n    }\n\n    private fun observeViewModels() {\n        authViewModel.loginResult.observe(this) { }\n\n        paiementViewModel.getPaiementsWithPayerByOperation(currentOperationId).observe(this) { payments ->\n            allPayments = payments\n            adapter.submitList(payments)\n        }\n\n        dashboardViewModel.allOperations.observe(this) { operations ->\n            val operation = operations.find { it.id == currentOperationId }\n            operation?.let {\n                binding.operationName.text = it.nom\n                binding.statusChip.text = it.statut\n                binding.operationDates.text = \"${dateFormat.format(it.dateDebut)} - ${\n                    it.dateFin?.let { date -> dateFormat.format(date) } ?: \"N/A\"\n                }\"\n                binding.montantCible.text = \"${formatter.format(it.montantCible)} FCFA\"\n\n                dashboardViewModel.loadOperationStats(listOf(currentOperationId))\n            }\n        }\n\n        dashboardViewModel.operationStats.observe(this) { stats ->\n            val stat = stats[currentOperationId]\n            stat?.let {\n                binding.montantCollecte.text = \"${formatter.format(it.montantCollecte)} FCFA\"\n                binding.montantRestant.text = \"${formatter.format(it.montantRestant)} FCFA\"\n                binding.progressBar.progress = it.pourcentage\n                binding.nombrePayeurs.text = \"${it.nombrePaiements} payeur${if (it.nombrePaiements > 1) \"s\" else \"\"}\"\n            }\n        }\n    }\n\n    override fun onResume() {\n        super.onResume()\n        loadAllUsers()\n    }\n\n    private fun loadAllUsers() {\n        authViewModel.loginResult.observe(this) { }\n\n        val sharedPrefs = getSharedPreferences(\"musep50_prefs\", MODE_PRIVATE)\n        val database = com.example.musep50.data.AppDatabase.getDatabase(this)\n        val repository = com.example.musep50.data.Repository(database)\n\n        repository.getAllUsers().observe(this) { users ->\n            allUsers = users\n        }\n    }\n}","size_bytes":5612},"AndroidProjects/app/src/main/java/com/example/musep50/data/AppDatabase.kt":{"content":"package com.example.musep50.data\n\nimport android.content.Context\nimport androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\nimport androidx.room.migration.Migration\nimport androidx.sqlite.db.SupportSQLiteDatabase\nimport com.example.musep50.data.dao.*\nimport com.example.musep50.data.entities.*\n\n@Database(\n    entities = [\n        User::class,\n        Event::class,\n        Operation::class,\n        Paiement::class,\n        Payer::class\n    ],\n    version = 4,\n    exportSchema = false\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    abstract fun eventDao(): EventDao\n    abstract fun operationDao(): OperationDao\n    abstract fun paiementDao(): PaiementDao\n    abstract fun payerDao(): PayerDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        private val MIGRATION_2_3 = object : Migration(2, 3) {\n            override fun migrate(database: SupportSQLiteDatabase) {\n                database.execSQL(\"\"\"\n                    CREATE TABLE IF NOT EXISTS events (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n                        nom TEXT NOT NULL,\n                        description TEXT,\n                        dateDebut INTEGER NOT NULL,\n                        dateFin INTEGER,\n                        statut TEXT NOT NULL,\n                        createdAt INTEGER NOT NULL\n                    )\n                \"\"\".trimIndent())\n\n                database.execSQL(\"\"\"\n                    INSERT INTO events (id, nom, description, dateDebut, statut, createdAt)\n                    VALUES (1, '√âv√©nement historique', 'Op√©rations existantes avant la mise √† jour', ${System.currentTimeMillis()}, 'Archiv√©', ${System.currentTimeMillis()})\n                \"\"\".trimIndent())\n\n                database.execSQL(\"\"\"\n                    CREATE TABLE IF NOT EXISTS operations_new (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n                        eventId INTEGER NOT NULL,\n                        nom TEXT NOT NULL,\n                        type TEXT NOT NULL,\n                        montantCible REAL NOT NULL,\n                        dateDebut INTEGER NOT NULL,\n                        dateFin INTEGER,\n                        statut TEXT NOT NULL,\n                        description TEXT,\n                        createdAt INTEGER NOT NULL,\n                        FOREIGN KEY(eventId) REFERENCES events(id) ON DELETE CASCADE\n                    )\n                \"\"\".trimIndent())\n\n                database.execSQL(\"\"\"\n                    CREATE INDEX IF NOT EXISTS index_operations_new_eventId ON operations_new(eventId)\n                \"\"\".trimIndent())\n\n                database.execSQL(\"\"\"\n                    INSERT INTO operations_new (id, eventId, nom, type, montantCible, dateDebut, dateFin, statut, description, createdAt)\n                    SELECT id, 1, nom, type, montantCible, dateDebut, dateFin, statut, description, createdAt\n                    FROM operations\n                \"\"\".trimIndent())\n\n                database.execSQL(\"DROP TABLE operations\")\n                database.execSQL(\"ALTER TABLE operations_new RENAME TO operations\")\n            }\n        }\n\n        private val MIGRATION_3_4 = object : Migration(3, 4) {\n            override fun migrate(database: SupportSQLiteDatabase) {\n                // Cr√©er une nouvelle table payers avec la colonne eventId\n                database.execSQL(\"\"\"\n                    CREATE TABLE IF NOT EXISTS payers_new (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n                        eventId INTEGER,\n                        nom TEXT NOT NULL,\n                        contact TEXT,\n                        note TEXT,\n                        createdAt INTEGER NOT NULL,\n                        FOREIGN KEY(eventId) REFERENCES events(id) ON DELETE CASCADE\n                    )\n                \"\"\".trimIndent())\n\n                // Cr√©er l'index pour eventId\n                database.execSQL(\"\"\"\n                    CREATE INDEX IF NOT EXISTS index_payers_eventId ON payers_new(eventId)\n                \"\"\".trimIndent())\n\n                // Copier les donn√©es existantes (eventId sera NULL pour les anciens payeurs)\n                database.execSQL(\"\"\"\n                    INSERT INTO payers_new (id, eventId, nom, contact, note, createdAt)\n                    SELECT id, NULL, nom, contact, note, createdAt\n                    FROM payers\n                \"\"\".trimIndent())\n\n                // Supprimer l'ancienne table et renommer la nouvelle\n                database.execSQL(\"DROP TABLE payers\")\n                database.execSQL(\"ALTER TABLE payers_new RENAME TO payers\")\n            }\n        }\n\n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"musep50_database\"\n                )\n                    .addMigrations(MIGRATION_2_3, MIGRATION_3_4)\n                    .fallbackToDestructiveMigration()\n                    .build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}","size_bytes":5332},"AndroidProjects/app/src/test/java/com/example/musep50/ExampleUnitTest.kt":{"content":"package com.example.musep50\n\nimport org.junit.Test\n\nimport org.junit.Assert.*\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\nclass ExampleUnitTest {\n    @Test\n    fun addition_isCorrect() {\n        assertEquals(4, 2 + 2)\n    }\n}","size_bytes":343},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/OperationViewModel.kt":{"content":"\npackage com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Operation\nimport kotlinx.coroutines.launch\n\nclass OperationViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    fun insertOperation(operation: Operation) {\n        viewModelScope.launch {\n            repository.insertOperation(operation)\n        }\n    }\n\n    fun updateOperation(operation: Operation) {\n        viewModelScope.launch {\n            repository.updateOperation(operation)\n        }\n    }\n\n    fun deleteOperation(operation: Operation) {\n        viewModelScope.launch {\n            repository.deleteOperation(operation)\n        }\n    }\n}\n","size_bytes":945},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/PaiementWithPayer.kt":{"content":"\npackage com.example.musep50.data.dao\n\nimport androidx.room.Embedded\nimport com.example.musep50.data.entities.Paiement\n\ndata class PaiementWithPayer(\n    @Embedded val paiement: Paiement,\n    val payerName: String,\n    val payerContact: String?\n)\n","size_bytes":247},"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/Paiement.kt":{"content":"\npackage com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(\n    tableName = \"paiements\",\n    foreignKeys = [\n        ForeignKey(\n            entity = Operation::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"operationId\"],\n            onDelete = ForeignKey.CASCADE\n        ),\n        ForeignKey(\n            entity = Payer::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"payerId\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [\n        Index(\"operationId\"),\n        Index(\"payerId\")\n    ]\n)\ndata class Paiement(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val operationId: Long,\n    val payerId: Long,\n    val montant: Double,\n    val montantDu: Double? = null,\n    val methodePaiement: String, // \"Esp√®ces\", \"Mobile Money\", \"Virement\", \"Autre\"\n    val statut: String = \"Valid√©\", // \"Valid√©\", \"En attente\", \"Annul√©\"\n    val commentaire: String? = null,\n    val referenceRecu: String? = null,\n    val datePaiement: Long = System.currentTimeMillis(),\n    val createdAt: Long = System.currentTimeMillis()\n)\n","size_bytes":1219},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/PaiementViewModel.kt":{"content":"package com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.dao.PaiementWithPayer\nimport com.example.musep50.data.entities.Paiement\nimport kotlinx.coroutines.launch\n\nclass PaiementViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    fun getPaiementsWithPayerByOperation(operationId: Long): LiveData<List<com.example.musep50.data.dao.PaiementWithPayer>> {\n        return repository.getPaiementsWithPayerByOperation(operationId)\n    }\n\n    fun insertPaiement(paiement: Paiement, onSuccess: () -> Unit, onError: (String) -> Unit) {\n        viewModelScope.launch {\n            try {\n                repository.insertPaiement(paiement)\n                onSuccess()\n            } catch (e: Exception) {\n                onError(e.message ?: \"Erreur lors de l'ajout du paiement\")\n            }\n        }\n    }\n\n    fun updatePaiement(paiement: Paiement) {\n        viewModelScope.launch {\n            repository.updatePaiement(paiement)\n        }\n    }\n\n    fun deletePaiement(paiement: Paiement) {\n        viewModelScope.launch {\n            repository.deletePaiement(paiement)\n        }\n    }\n}\n","size_bytes":1447},"AndroidProjects/app/src/main/java/com/example/musep50/ui/NewOperationActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.app.DatePickerDialog\nimport android.os.Bundle\nimport android.widget.ArrayAdapter\nimport android.widget.Toast\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.musep50.data.entities.Operation\nimport com.example.musep50.databinding.ActivityNewOperationBinding\nimport com.example.musep50.viewmodel.OperationViewModel\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nclass NewOperationActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityNewOperationBinding\n    private val viewModel: OperationViewModel by viewModels()\n    private val calendar = Calendar.getInstance()\n    private val dateFormat = SimpleDateFormat(\"dd/MM/yyyy\", Locale.FRANCE)\n    private var dateDebut: Date? = null\n    private var dateFin: Date? = null\n    private var eventId: Long = -1\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNewOperationBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        eventId = intent.getLongExtra(\"event_id\", -1)\n\n        if (eventId == -1L) {\n            Toast.makeText(this, \"Erreur: Aucun √©v√©nement s√©lectionn√©\", Toast.LENGTH_SHORT).show()\n            finish()\n            return\n        }\n\n        setupToolbar()\n        setupTypeDropdown()\n        setupDatePickers()\n        setupCreateButton()\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun setupTypeDropdown() {\n        val types = arrayOf(\"ADHESION\", \"COTISATION_EXCEPTIONNELLE\", \"FONDS_CAISSE\")\n        val adapter = ArrayAdapter(this, android.R.layout.simple_dropdown_item_1line, types)\n        binding.typeInput.setAdapter(adapter)\n    }\n\n    private fun setupDatePickers() {\n        binding.dateDebutInput.setOnClickListener {\n            showDatePicker { date ->\n                dateDebut = date\n                binding.dateDebutInput.setText(dateFormat.format(date))\n            }\n        }\n\n        binding.dateFinInput.setOnClickListener {\n            showDatePicker { date ->\n                dateFin = date\n                binding.dateFinInput.setText(dateFormat.format(date))\n            }\n        }\n    }\n\n    private fun showDatePicker(onDateSelected: (Date) -> Unit) {\n        val year = calendar.get(Calendar.YEAR)\n        val month = calendar.get(Calendar.MONTH)\n        val day = calendar.get(Calendar.DAY_OF_MONTH)\n\n        DatePickerDialog(this, { _, selectedYear, selectedMonth, selectedDay ->\n            calendar.set(selectedYear, selectedMonth, selectedDay)\n            onDateSelected(calendar.time)\n        }, year, month, day).show()\n    }\n\n    private fun setupCreateButton() {\n        binding.createButton.setOnClickListener {\n            val nom = binding.nomInput.text.toString()\n            val type = binding.typeInput.text.toString()\n            val montantStr = binding.montantInput.text.toString()\n\n            if (validateInputs(nom, type, montantStr)) {\n                val montant = montantStr.toDouble()\n                val operation = Operation(\n                    eventId = eventId,\n                    nom = nom,\n                    type = type,\n                    montantCible = montant,\n                    dateDebut = dateDebut?.time ?: System.currentTimeMillis(),\n                    dateFin = dateFin?.time,\n                    statut = \"En cours\"\n                )\n\n                viewModel.insertOperation(operation)\n                Toast.makeText(this, \"Op√©ration cr√©√©e avec succ√®s\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n\n    private fun validateInputs(nom: String, type: String, montantStr: String): Boolean {\n        if (nom.isBlank()) {\n            binding.nomInputLayout.error = \"Le nom est requis\"\n            return false\n        }\n\n        if (type.isBlank()) {\n            binding.typeInputLayout.error = \"Le type est requis\"\n            return false\n        }\n\n        if (montantStr.isBlank()) {\n            binding.montantInputLayout.error = \"Le montant est requis\"\n            return false\n        }\n\n        if (dateDebut == null) {\n            Toast.makeText(this, \"Veuillez s√©lectionner la date de d√©but\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        if (dateFin == null) {\n            Toast.makeText(this, \"Veuillez s√©lectionner la date de fin\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        if (dateFin!!.before(dateDebut)) {\n            Toast.makeText(this, \"La date de fin doit √™tre apr√®s la date de d√©but\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        return true\n    }\n}","size_bytes":4872},"AndroidProjects/app/src/androidTest/java/com/example/musep50/ExampleInstrumentedTest.kt":{"content":"package com.example.musep50\n\nimport androidx.test.platform.app.InstrumentationRegistry\nimport androidx.test.ext.junit.runners.AndroidJUnit4\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\nimport org.junit.Assert.*\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass ExampleInstrumentedTest {\n    @Test\n    fun useAppContext() {\n        // Context of the app under test.\n        val appContext = InstrumentationRegistry.getInstrumentation().targetContext\n        assertEquals(\"com.example.musep50\", appContext.packageName)\n    }\n}","size_bytes":665},"AndroidProjects/app/src/main/java/com/example/musep50/ui/adapter/RetardataireAdapter.kt":{"content":"package com.example.musep50.ui.adapter\n\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.DiffUtil\nimport androidx.recyclerview.widget.ListAdapter\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.musep50.data.entities.User\nimport com.example.musep50.databinding.ItemRetardataireBinding\n\nclass RetardataireAdapter(\n    private val onSelectionChanged: (List<User>) -> Unit,\n    private val onSendIndividual: (User) -> Unit\n) : ListAdapter<User, RetardataireAdapter.RetardataireViewHolder>(RetardataireDiffCallback()) {\n\n    private val selectedUsers = mutableSetOf<Long>()\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RetardataireViewHolder {\n        val binding = ItemRetardataireBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return RetardataireViewHolder(binding)\n    }\n\n    override fun onBindViewHolder(holder: RetardataireViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n\n    fun selectAll() {\n        selectedUsers.clear()\n        currentList.forEach { selectedUsers.add(it.id) }\n        notifyDataSetChanged()\n        notifySelectionChanged()\n    }\n\n    fun clearSelection() {\n        selectedUsers.clear()\n        notifyDataSetChanged()\n        notifySelectionChanged()\n    }\n\n    private fun notifySelectionChanged() {\n        val selected = currentList.filter { selectedUsers.contains(it.id) }\n        onSelectionChanged(selected)\n    }\n\n    inner class RetardataireViewHolder(\n        private val binding: ItemRetardataireBinding\n    ) : RecyclerView.ViewHolder(binding.root) {\n\n        fun bind(user: User) {\n            binding.userName.text = user.nom\n            binding.userEmail.text = user.email\n            \n            if (!user.telephone.isNullOrBlank()) {\n                binding.userPhone.visibility = View.VISIBLE\n                binding.userPhone.text = \"üìû ${user.telephone}\"\n            } else {\n                binding.userPhone.visibility = View.GONE\n            }\n\n            binding.checkbox.isChecked = selectedUsers.contains(user.id)\n            binding.checkbox.setOnCheckedChangeListener { _, isChecked ->\n                if (isChecked) {\n                    selectedUsers.add(user.id)\n                } else {\n                    selectedUsers.remove(user.id)\n                }\n                notifySelectionChanged()\n            }\n\n            binding.btnSendIndividual.setOnClickListener {\n                onSendIndividual(user)\n            }\n        }\n    }\n}\n\nclass RetardataireDiffCallback : DiffUtil.ItemCallback<User>() {\n    override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {\n        return oldItem.id == newItem.id\n    }\n\n    override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {\n        return oldItem == newItem\n    }\n}\n","size_bytes":2930},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/PayerViewModel.kt":{"content":"package com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Payer\nimport kotlinx.coroutines.launch\n\nclass PayerViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    fun getAllPayers(): LiveData<List<Payer>> {\n        return repository.getAllPayers()\n    }\n\n    suspend fun getAllPayersSync(): List<Payer> {\n        return repository.getAllPayersSync()\n    }\n\n    fun searchPayers(query: String): LiveData<List<Payer>> {\n        return repository.searchPayers(query)\n    }\n\n    suspend fun insertPayer(payer: Payer): Long {\n        return repository.insertPayer(payer)\n    }\n\n    fun updatePayer(payer: Payer) {\n        viewModelScope.launch {\n            repository.updatePayer(payer)\n        }\n    }\n\n    fun deletePayer(payer: Payer) {\n        viewModelScope.launch {\n            repository.deletePayer(payer)\n        }\n    }\n}","size_bytes":1197},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/OperationDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.Operation\n\n@Dao\ninterface OperationDao {\n    @Query(\"SELECT * FROM operations ORDER BY createdAt DESC\")\n    fun getAllOperations(): LiveData<List<Operation>>\n\n    @Query(\"SELECT * FROM operations WHERE id = :id\")\n    suspend fun getOperationById(id: Long): Operation?\n\n    @Query(\"SELECT * FROM operations WHERE id = :id\")\n    fun getOperationByIdLive(id: Long): LiveData<Operation?>\n\n    @Query(\"SELECT * FROM operations WHERE statut = 'En cours' ORDER BY createdAt DESC\")\n    fun getActiveOperations(): LiveData<List<Operation>>\n\n    @Query(\"SELECT * FROM operations WHERE type = :type ORDER BY createdAt DESC\")\n    fun getOperationsByType(type: String): LiveData<List<Operation>>\n\n    @Insert(onConflict = OnConflictStrategy.ABORT)\n    suspend fun insert(operation: Operation): Long\n\n    @Update\n    suspend fun update(operation: Operation)\n\n    @Delete\n    suspend fun delete(operation: Operation)\n\n    @Query(\"UPDATE operations SET statut = 'Cl√¥tur√©' WHERE id = :operationId\")\n    suspend fun closeOperation(operationId: Long)\n\n    @Query(\"SELECT * FROM operations WHERE statut = :statut ORDER BY dateDebut DESC\")\n    fun getOperationsByState(statut: String): LiveData<List<Operation>>\n\n    @Query(\"SELECT * FROM operations WHERE statut = :statut ORDER BY dateDebut DESC\")\n    fun getOperationsByEtat(statut: String): LiveData<List<Operation>>\n\n    @Query(\"SELECT * FROM operations WHERE eventId = :eventId ORDER BY createdAt DESC\")\n    fun getOperationsByEvent(eventId: Long): LiveData<List<Operation>>\n}","size_bytes":1649},"AndroidProjects/app/src/main/java/com/example/musep50/ui/AddPaymentDialog.kt":{"content":"package com.example.musep50.ui\n\nimport android.app.Dialog\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.ArrayAdapter\nimport android.widget.Toast\nimport androidx.fragment.app.DialogFragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport com.example.musep50.data.entities.Paiement\nimport com.example.musep50.databinding.DialogAddPaymentBinding\nimport com.example.musep50.viewmodel.PaiementViewModel\nimport com.example.musep50.viewmodel.PayerViewModel\nimport com.google.android.material.dialog.MaterialAlertDialogBuilder\nimport kotlinx.coroutines.launch\n\nclass AddPaymentDialog(\n    private val operationId: Long,\n    private val onPaymentAdded: () -> Unit\n) : DialogFragment() {\n\n    private var _binding: DialogAddPaymentBinding? = null\n    private val binding get() = _binding!!\n    private val paiementViewModel: PaiementViewModel by viewModels()\n    private val payerViewModel: PayerViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = DialogAddPaymentBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // Set dialog style\n        dialog?.window?.setBackgroundDrawableResource(android.R.color.transparent)\n\n        setupPayerInput()\n        setupMethodDropdown()\n        setupButtons()\n    }\n\n    private fun setupPayerInput() {\n        // User can type a new payer name or select from existing\n        payerViewModel.getAllPayers().observe(viewLifecycleOwner) { payers ->\n            val payerNames = payers.map { it.nom }\n            val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, payerNames)\n            binding.userInput.setAdapter(adapter)\n        }\n\n        binding.btnAddPayer.setOnClickListener {\n            // Show dialog to add new payer\n            AddPayerDialog {\n                // Refresh the payer list after adding\n                payerViewModel.getAllPayers().observe(viewLifecycleOwner) { payers ->\n                    val payerNames = payers.map { it.nom }\n                    val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, payerNames)\n                    binding.userInput.setAdapter(adapter)\n                    // Select the last added payer\n                    if (payerNames.isNotEmpty()) {\n                        binding.userInput.setText(payerNames.last(), false)\n                    }\n                }\n            }.show(parentFragmentManager, AddPayerDialog.TAG)\n        }\n    }\n\n    private fun setupMethodDropdown() {\n        val methods = arrayOf(\"Esp√®ces\", \"Mobile Money\", \"Virement\", \"Autre\")\n        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, methods)\n        binding.methodInput.setAdapter(adapter)\n    }\n\n    private fun setupButtons() {\n        binding.btnCancel.setOnClickListener {\n            dismiss()\n        }\n\n        binding.btnSave.setOnClickListener {\n            if (validateInputs()) {\n                savePaiement()\n            }\n        }\n    }\n\n    private fun validateInputs(): Boolean {\n        val payerName = binding.userInput.text.toString()\n        if (payerName.isBlank()) {\n            binding.userInputLayout.error = \"Le nom du payeur est requis\"\n            return false\n        }\n\n        val montantStr = binding.montantInput.text.toString()\n        if (montantStr.isBlank()) {\n            binding.montantInputLayout.error = \"Le montant est requis\"\n            return false\n        }\n\n        val method = binding.methodInput.text.toString()\n        if (method.isBlank()) {\n            binding.methodInputLayout.error = \"La m√©thode de paiement est requise\"\n            return false\n        }\n\n        return true\n    }\n\n    private fun savePaiement() {\n        val payerName = binding.userInput.text.toString()\n        val montant = binding.montantInput.text.toString().toDouble()\n        val method = binding.methodInput.text.toString()\n        val commentaire = binding.commentaireInput.text?.toString()\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            // First, check if payer exists or create new one\n            val payers = payerViewModel.getAllPayersSync()\n            var payerId = payers.find { it.nom.equals(payerName, ignoreCase = true) }?.id\n\n            if (payerId == null) {\n                // Create new payer\n                val newPayer = com.example.musep50.data.entities.Payer(\n                    nom = payerName,\n                    contact = null,\n                    note = null\n                )\n\n                payerId = payerViewModel.insertPayer(newPayer)\n            }\n\n            val paiement = Paiement(\n                operationId = operationId,\n                payerId = payerId,\n                montant = montant,\n                datePaiement = System.currentTimeMillis(),\n                methodePaiement = method,\n                commentaire = commentaire,\n                statut = \"Valid√©\"\n            )\n\n            paiementViewModel.insertPaiement(paiement,\n                onSuccess = {\n                    Toast.makeText(requireContext(), \"Paiement enregistr√©\", Toast.LENGTH_SHORT).show()\n                    onPaymentAdded()\n                    dismiss()\n                },\n                onError = { error ->\n                    Toast.makeText(requireContext(), error, Toast.LENGTH_SHORT).show()\n                }\n            )\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n\n    companion object {\n        const val TAG = \"AddPaymentDialog\"\n    }\n}","size_bytes":5917},"AndroidProjects/app/src/main/java/com/example/musep50/ui/PublishActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.content.ClipData\nimport android.content.ClipboardManager\nimport android.content.Context\nimport android.content.Intent\nimport android.os.Bundle\nimport android.os.Environment\nimport android.widget.Toast\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.dao.PaiementWithPayer\nimport com.example.musep50.data.entities.Operation\nimport com.example.musep50.databinding.ActivityPublishBinding\nimport com.example.musep50.viewmodel.DashboardViewModel\nimport com.example.musep50.viewmodel.PaiementViewModel\nimport kotlinx.coroutines.launch\nimport java.io.File\nimport java.io.FileWriter\nimport java.text.NumberFormat\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nclass PublishActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityPublishBinding\n    private val dashboardViewModel: DashboardViewModel by viewModels()\n    private val paiementViewModel: PaiementViewModel by viewModels()\n    private var currentOperation: Operation? = null\n    private var payments = listOf<PaiementWithPayer>()\n    private val dateFormat = SimpleDateFormat(\"dd/MM/yyyy\", Locale.FRANCE)\n    private val formatter = NumberFormat.getNumberInstance(Locale.FRANCE)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityPublishBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        val operationId = intent.getLongExtra(\"operation_id\", -1L)\n\n        setupToolbar()\n        setupButtons()\n        loadData(operationId)\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun setupButtons() {\n        binding.btnCopyText.setOnClickListener {\n            copyToClipboard()\n        }\n\n        binding.btnShareWhatsapp.setOnClickListener {\n            shareOnWhatsApp()\n        }\n\n        binding.btnShareOther.setOnClickListener {\n            shareToOtherApps()\n        }\n\n        binding.btnExportCsv.setOnClickListener {\n            exportToCsv()\n        }\n    }\n\n    private fun loadData(operationId: Long) {\n        dashboardViewModel.allOperations.observe(this) { operations ->\n            currentOperation = operations.find { it.id == operationId }\n            updatePreview()\n        }\n\n        paiementViewModel.getPaiementsWithPayerByOperation(operationId).observe(this) { paymentsData ->\n            payments = paymentsData\n            updatePreview()\n        }\n    }\n\n    private fun updatePreview() {\n        val operation = currentOperation ?: return\n        val text = generateFormattedList(operation, payments)\n        binding.previewText.text = text\n    }\n\n    private fun generateFormattedList(operation: Operation, payments: List<PaiementWithPayer>): String {\n        val builder = StringBuilder()\n\n        builder.appendLine(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n        builder.appendLine(\"üìã MUSEP50 - ${operation.nom}\")\n        builder.appendLine(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n        builder.appendLine()\n        builder.appendLine(\"üìÖ P√©riode: ${dateFormat.format(operation.dateDebut)} - ${operation.dateFin?.let { dateFormat.format(it) } ?: \"N/A\"}\")\n        builder.appendLine(\"üí∞ Montant cibl√©: ${formatter.format(operation.montantCible)} FCFA\")\n        builder.appendLine()\n\n        val totalCollecte = payments.sumOf { it.paiement.montant }\n        val montantRestant = operation.montantCible - totalCollecte\n\n        builder.appendLine(\"üìä STATISTIQUES\")\n        builder.appendLine(\"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\")\n        builder.appendLine(\"‚úÖ Montant collect√©: ${formatter.format(totalCollecte)} FCFA\")\n        builder.appendLine(\"‚è≥ Montant restant: ${formatter.format(montantRestant)} FCFA\")\n        builder.appendLine(\"üë• Nombre de payeurs: ${payments.size}\")\n        builder.appendLine()\n\n        builder.appendLine(\"üìù LISTE DES PAIEMENTS\")\n        builder.appendLine(\"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\")\n\n        if (payments.isEmpty()) {\n            builder.appendLine(\"Aucun paiement enregistr√©\")\n        } else {\n            payments.forEachIndexed { index, paiementWithUser ->\n                builder.appendLine()\n                builder.appendLine(\"${index + 1}. ${paiementWithUser.payerName} - ${formatter.format(paiementWithUser.paiement.montant)} FCFA\")\n                builder.appendLine(\"   üìÖ Date: ${dateFormat.format(paiementWithUser.paiement.datePaiement)}\")\n                builder.appendLine(\"   üí≥ M√©thode: ${paiementWithUser.paiement.methodePaiement}\")\n                if (!paiementWithUser.paiement.commentaire.isNullOrBlank()) {\n                    builder.appendLine(\"   üìù Note: ${paiementWithUser.paiement.commentaire}\")\n                }\n            }\n        }\n\n        builder.appendLine()\n        builder.appendLine(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n        builder.appendLine(\"G√©n√©r√© le ${dateFormat.format(Date())}\")\n        builder.appendLine(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\")\n\n        return builder.toString()\n    }\n\n    private fun copyToClipboard() {\n        val text = binding.previewText.text.toString()\n        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\n        val clip = ClipData.newPlainText(\"Liste de paiements\", text)\n        clipboard.setPrimaryClip(clip)\n        Toast.makeText(this, \"Texte copi√© dans le presse-papiers\", Toast.LENGTH_SHORT).show()\n    }\n\n    private fun shareOnWhatsApp() {\n        val text = binding.previewText.text.toString()\n        val sendIntent = Intent().apply {\n            action = Intent.ACTION_SEND\n            putExtra(Intent.EXTRA_TEXT, text)\n            type = \"text/plain\"\n            setPackage(\"com.whatsapp\")\n        }\n\n        try {\n            startActivity(sendIntent)\n        } catch (e: Exception) {\n            Toast.makeText(this, \"WhatsApp n'est pas install√©\", Toast.LENGTH_SHORT).show()\n            shareToOtherApps()\n        }\n    }\n\n    private fun shareToOtherApps() {\n        val text = binding.previewText.text.toString()\n        val sendIntent = Intent().apply {\n            action = Intent.ACTION_SEND\n            putExtra(Intent.EXTRA_TEXT, text)\n            type = \"text/plain\"\n        }\n        val shareIntent = Intent.createChooser(sendIntent, \"Partager via\")\n        startActivity(shareIntent)\n    }\n\n    private fun exportToCsv() {\n        val operation = currentOperation ?: return\n\n        lifecycleScope.launch {\n            try {\n                val fileName = \"musep50_${operation.nom.replace(\" \", \"_\")}_${System.currentTimeMillis()}.csv\"\n                val file = File(getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), fileName)\n\n                FileWriter(file).use { writer ->\n                    writer.append(\"Nom du payeur,Contact,Montant (FCFA),Date,M√©thode,Commentaire\\n\")\n\n                    payments.forEach { payment ->\n                        writer.append(\"\\\"${payment.payerName}\\\",\")\n                        val payerInfo = if (payment.payerContact.isNullOrBlank()) {\n                            payment.payerName\n                        } else {\n                            \"${payment.payerName} (${payment.payerContact})\"\n                        }\n                        writer.append(\"\\\"${payerInfo}\\\",\")\n                        writer.append(\"${payment.paiement.montant},\")\n                        writer.append(\"\\\"${dateFormat.format(payment.paiement.datePaiement)}\\\",\")\n                        writer.append(\"\\\"${payment.paiement.methodePaiement}\\\",\")\n                        writer.append(\"\\\"${payment.paiement.commentaire ?: \"\"}\\\"\\n\")\n                    }\n                }\n\n                Toast.makeText(\n                    this@PublishActivity,\n                    \"CSV export√©: ${file.absolutePath}\",\n                    Toast.LENGTH_LONG\n                ).show()\n            } catch (e: Exception) {\n                Toast.makeText(\n                    this@PublishActivity,\n                    \"Erreur lors de l'export: ${e.message}\",\n                    Toast.LENGTH_LONG\n                ).show()\n            }\n        }\n    }\n}","size_bytes":8707},"AndroidProjects/app/src/main/java/com/example/musep50/ui/LoginActivity.kt":{"content":"\npackage com.example.musep50.ui\n\nimport android.content.Intent\nimport android.os.Bundle\nimport android.view.View\nimport android.widget.Toast\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.musep50.R\nimport com.example.musep50.databinding.ActivityLoginBinding\nimport com.example.musep50.viewmodel.AuthViewModel\nimport com.example.musep50.viewmodel.LoginResult\n\nclass LoginActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityLoginBinding\n    private val viewModel: AuthViewModel by viewModels()\n    private var currentPin = \"\"\n    private var currentEmail = \"\"\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityLoginBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        setupEmailStep()\n        setupPinStep()\n        observeViewModel()\n    }\n    \n    private fun setupPinStep() {\n        val pinButtons = listOf(\n            binding.pinKeypad.btn0,\n            binding.pinKeypad.btn1,\n            binding.pinKeypad.btn2,\n            binding.pinKeypad.btn3,\n            binding.pinKeypad.btn4,\n            binding.pinKeypad.btn5,\n            binding.pinKeypad.btn6,\n            binding.pinKeypad.btn7,\n            binding.pinKeypad.btn8,\n            binding.pinKeypad.btn9\n        )\n        \n        pinButtons.forEachIndexed { index, button ->\n            button.setOnClickListener {\n                addPinDigit(index.toString())\n            }\n        }\n        \n        binding.pinKeypad.btnDelete.setOnClickListener {\n            removePinDigit()\n        }\n        \n        binding.pinKeypad.btnBack.setOnClickListener {\n            showEmailStep()\n        }\n    }\n    \n    private fun setupEmailStep() {\n        binding.continueButton.setOnClickListener {\n            val email = binding.emailInput.text.toString()\n            if (email.isNotEmpty()) {\n                currentEmail = email\n                // V√©rifier si l'utilisateur existe en tentant la connexion\n                showPinStep()\n            } else {\n                Toast.makeText(this, \"Veuillez entrer votre email\", Toast.LENGTH_SHORT).show()\n            }\n        }\n        \n        binding.registerButton.setOnClickListener {\n            startActivity(Intent(this, RegisterActivity::class.java))\n        }\n    }\n    \n    private fun addPinDigit(digit: String) {\n        if (currentPin.length < 4) {\n            currentPin += digit\n            updatePinDots()\n            \n            if (currentPin.length == 4) {\n                viewModel.login(currentEmail, currentPin)\n            }\n        }\n    }\n    \n    private fun removePinDigit() {\n        if (currentPin.isNotEmpty()) {\n            currentPin = currentPin.dropLast(1)\n            updatePinDots()\n        }\n    }\n    \n    private fun updatePinDots() {\n        val dots = listOf(\n            binding.pinDot1,\n            binding.pinDot2,\n            binding.pinDot3,\n            binding.pinDot4\n        )\n        \n        dots.forEachIndexed { index, dot ->\n            if (index < currentPin.length) {\n                dot.setBackgroundResource(R.drawable.pin_dot_filled)\n            } else {\n                dot.setBackgroundResource(R.drawable.pin_dot_empty)\n            }\n        }\n    }\n    \n    private fun showEmailStep() {\n        binding.emailInputLayout.visibility = View.VISIBLE\n        binding.pinLayout.visibility = View.GONE\n        binding.continueButton.visibility = View.VISIBLE\n        binding.registerButton.visibility = View.VISIBLE\n        binding.subtitleText.text = \"Entrez votre adresse email\"\n        currentPin = \"\"\n        updatePinDots()\n    }\n    \n    private fun showPinStep() {\n        binding.emailInputLayout.visibility = View.GONE\n        binding.pinLayout.visibility = View.VISIBLE\n        binding.continueButton.visibility = View.GONE\n        binding.registerButton.visibility = View.GONE\n        binding.subtitleText.text = \"Entrez votre code PIN\"\n    }\n    \n    private fun observeViewModel() {\n        viewModel.loginResult.observe(this) { result ->\n            when (result) {\n                is LoginResult.Success -> {\n                    val sharedPreferences = getSharedPreferences(\"musep50_prefs\", MODE_PRIVATE)\n                    sharedPreferences.edit().putLong(\"current_user_id\", result.user.id).apply()\n                    \n                    startActivity(Intent(this, DashboardActivity::class.java))\n                    finish()\n                }\n                is LoginResult.Error -> {\n                    currentPin = \"\"\n                    updatePinDots()\n                    Toast.makeText(this, result.message, Toast.LENGTH_SHORT).show()\n                }\n            }\n        }\n    }\n}\n","size_bytes":4771},"RAPPORT_TP_SEANCE4.md":{"content":"# Rapport TP - S√©ance 4 : Enregistrement & Persistance\n\n**Projet** : MUSEP50 - Application de gestion financi√®re  \n**Technologies** : Kotlin, Room Database, RecyclerView  \n**Date** : 8 octobre 2025\n\n---\n\n## üìã Objectifs du TP\n\n- ‚úÖ Ajout de donn√©es dans la base via formulaire\n- ‚úÖ Lecture/affichage en RecyclerView\n- ‚úÖ V√©rification que les donn√©es persistent apr√®s fermeture de l'app\n\n---\n\n## 1Ô∏è‚É£ Livrable 1 : Ajout de donn√©es dans la base via formulaire\n\n### üìù Description\nL'application dispose d'un formulaire permettant d'ajouter des paiements dans la base de donn√©es Room. Le formulaire contient tous les champs n√©cessaires avec validation.\n\n### üîß Impl√©mentation\n- **Fichier layout** : `res/layout/dialog_add_payment.xml`\n- **Base de donn√©es** : Room Database avec DAO\n- **Entit√©** : `Paiement` (montant, date, m√©thode, commentaire)\n\n### üì∏ Captures d'√©cran\n\n#### Screenshot 1 : Formulaire d'ajout de paiement\n![Formulaire vide - pr√™t pour saisie]()\n\n*Ins√©rer ici : Capture montrant le formulaire avec les champs :*\n- *S√©lection du payeur (dropdown)*\n- *Champ montant en FCFA*\n- *M√©thode de paiement*\n- *Commentaire optionnel*\n- *Boutons \"Annuler\" et \"Enregistrer\"*\n\n---\n\n#### Screenshot 2 : Formulaire rempli\n![Formulaire avec donn√©es saisies]()\n\n*Ins√©rer ici : Capture montrant le formulaire compl√©t√© avec :*\n- *Un payeur s√©lectionn√©*\n- *Un montant saisi (ex: 5000 FCFA)*\n- *Une m√©thode de paiement choisie*\n- *Un commentaire ajout√©*\n\n---\n\n## 2Ô∏è‚É£ Livrable 2 : Lecture/affichage en RecyclerView\n\n### üìù Description\nLes donn√©es sont affich√©es dans un RecyclerView avec un adapter personnalis√©. L'application dispose de plusieurs RecyclerView pour diff√©rents types de donn√©es.\n\n### üîß Impl√©mentation\n- **Adapter 1** : `OperationAdapter.kt` - Liste des op√©rations\n- **Adapter 2** : `PaymentAdapter.kt` - Liste des paiements avec d√©tails\n- **Adapter 3** : `RetardataireAdapter.kt` - Liste des retardataires\n- **ViewBinding** : Utilisation de ViewBinding pour les items\n\n### üì∏ Captures d'√©cran\n\n#### Screenshot 3 : RecyclerView des op√©rations\n![Liste des op√©rations dans le Dashboard]()\n\n*Ins√©rer ici : Capture montrant le RecyclerView avec :*\n- *Plusieurs op√©rations affich√©es*\n- *Nom, type et statut de chaque op√©ration*\n- *Statistiques (montant collect√©, restant, progression)*\n- *Nombre de payeurs*\n\n---\n\n#### Screenshot 4 : RecyclerView des paiements\n![Liste d√©taill√©e des paiements d'une op√©ration]()\n\n*Ins√©rer ici : Capture montrant le RecyclerView des paiements avec :*\n- *Nom du payeur*\n- *Montant pay√© en FCFA*\n- *Date de paiement*\n- *M√©thode de paiement*\n- *Commentaire (si pr√©sent)*\n\n---\n\n#### Screenshot 5 : D√©tail d'un item du RecyclerView\n![Vue rapproch√©e d'un item de paiement]()\n\n*Ins√©rer ici : Capture zoom√©e sur un seul item montrant tous les d√©tails*\n\n---\n\n## 3Ô∏è‚É£ Livrable 3 : V√©rification de la persistance apr√®s fermeture\n\n### üìù Description\nLes donn√©es sont stock√©es dans une base Room SQLite locale. La persistance est automatique et les donn√©es restent disponibles m√™me apr√®s fermeture compl√®te de l'application.\n\n### üîß Impl√©mentation\n- **Base de donn√©es** : `AppDatabase.kt` (Room Database)\n- **Nom de la base** : `musep50_database`\n- **Entit√©s** : User, Operation, Paiement, Payer\n- **Version** : 2 avec migration automatique\n\n### üì∏ Captures d'√©cran - Test de persistance\n\n#### Screenshot 6 : Donn√©es affich√©es AVANT fermeture de l'app\n![√âtat de l'application avec des donn√©es]()\n\n*Ins√©rer ici : Capture montrant :*\n- *Le RecyclerView avec plusieurs paiements enregistr√©s*\n- *Les statistiques √† jour*\n- *Note visible : \"AVANT FERMETURE\"*\n\n---\n\n#### Screenshot 7 : Application ferm√©e (gestionnaire de t√¢ches)\n![Gestionnaire de t√¢ches Android - App ferm√©e]()\n\n*Ins√©rer ici : Capture du gestionnaire de t√¢ches Android montrant :*\n- *L'application est bien ferm√©e (pas dans les apps r√©centes)*\n- *OU capture du bouton \"Forcer l'arr√™t\" dans les param√®tres de l'app*\n\n---\n\n#### Screenshot 8 : Donn√©es affich√©es APR√àS r√©ouverture de l'app\n![Application rouverte - donn√©es toujours pr√©sentes]()\n\n*Ins√©rer ici : Capture montrant :*\n- *Le m√™me RecyclerView avec les M√äMES donn√©es*\n- *Aucune perte de donn√©es*\n- *Les statistiques identiques*\n- *Note visible : \"APR√àS R√âOUVERTURE\"*\n\n---\n\n## üìä Architecture technique\n\n### Base de donn√©es Room\n```kotlin\n@Database(\n    entities = [User::class, Operation::class, Paiement::class, Payer::class],\n    version = 2,\n    exportSchema = false\n)\nabstract class AppDatabase : RoomDatabase()\n```\n\n### DAO pour les op√©rations CRUD\n- `UserDao` : Gestion des utilisateurs\n- `OperationDao` : Gestion des op√©rations\n- `PaiementDao` : Gestion des paiements\n- `PayerDao` : Gestion des payeurs\n\n### Pattern MVVM\n- **ViewModel** : `DashboardViewModel`, `AuthViewModel`\n- **LiveData** : Observation r√©active des donn√©es\n- **Coroutines** : Op√©rations asynchrones\n\n---\n\n## ‚úÖ Conclusion\n\nCe projet d√©montre une impl√©mentation compl√®te des concepts de persistance locale sur Android :\n\n1. ‚úÖ **Formulaire fonctionnel** permettant l'ajout de donn√©es structur√©es\n2. ‚úÖ **RecyclerView optimis√©** avec DiffUtil pour l'affichage performant\n3. ‚úÖ **Persistance garantie** gr√¢ce √† Room Database SQLite\n\nTous les livrables du TP sont fonctionnels et test√©s avec succ√®s.\n\n---\n\n## üìù Instructions pour les captures d'√©cran\n\n### Comment prendre les captures :\n1. **Lancez l'app** dans Android Studio sur un √©mulateur\n2. **Pour le formulaire** : Ouvrez le dialog d'ajout de paiement\n3. **Pour le RecyclerView** : Naviguez vers la liste des paiements\n4. **Pour la persistance** :\n   - Prenez un screenshot de l'app avec des donn√©es\n   - Fermez compl√®tement l'app (Forcer l'arr√™t)\n   - Rouvrez l'app et prenez un nouveau screenshot\n\n### Emplacements des screenshots dans ce document :\n- Remplacez chaque `![]()` par `![Description](chemin/vers/image.png)`\n- Ou ins√©rez directement les images dans votre √©diteur markdown\n\n---\n\n**üéì Travail r√©alis√© dans le cadre du TP S√©ance 4 - Enregistrement & Persistance**\n","size_bytes":6110},"AndroidProjects/app/src/main/java/com/example/musep50/ui/DashboardActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.content.Intent\nimport android.os.Bundle\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.core.widget.doOnTextChanged\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.musep50.R\nimport com.example.musep50.data.entities.Event\nimport com.example.musep50.databinding.ActivityDashboardBinding\nimport com.example.musep50.ui.adapter.EventAdapter\nimport com.example.musep50.viewmodel.EventViewModel\n\nclass DashboardActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityDashboardBinding\n    private val viewModel: EventViewModel by viewModels()\n    private lateinit var adapter: EventAdapter\n    private var allEvents = listOf<Event>()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityDashboardBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        setSupportActionBar(binding.toolbar)\n        \n        setupRecyclerView()\n        setupSearchBar()\n        setupFab()\n        observeViewModel()\n    }\n    \n    private fun setupRecyclerView() {\n        adapter = EventAdapter { event ->\n            val intent = Intent(this, EventOperationsActivity::class.java)\n            intent.putExtra(\"event_id\", event.id)\n            startActivity(intent)\n        }\n        \n        binding.eventsRecyclerView.layoutManager = LinearLayoutManager(this)\n        binding.eventsRecyclerView.adapter = adapter\n    }\n    \n    private fun setupSearchBar() {\n        binding.searchInput.doOnTextChanged { text, _, _, _ ->\n            filterEvents(text.toString())\n        }\n    }\n    \n    private fun setupFab() {\n        binding.fabNewEvent.setOnClickListener {\n            startActivity(Intent(this, NewEventActivity::class.java))\n        }\n    }\n    \n    private fun filterEvents(query: String) {\n        val filtered = if (query.isBlank()) {\n            allEvents\n        } else {\n            allEvents.filter {\n                it.nom.contains(query, ignoreCase = true) ||\n                (it.description?.contains(query, ignoreCase = true) == true)\n            }\n        }\n        adapter.submitList(filtered)\n        updateEmptyState(filtered.isEmpty())\n    }\n    \n    private fun updateEmptyState(isEmpty: Boolean) {\n        binding.emptyStateLayout.visibility = if (isEmpty) View.VISIBLE else View.GONE\n        binding.eventsRecyclerView.visibility = if (isEmpty) View.GONE else View.VISIBLE\n    }\n    \n    private fun observeViewModel() {\n        viewModel.allEvents.observe(this) { events ->\n            allEvents = events\n            adapter.submitList(events)\n            updateEmptyState(events.isEmpty())\n        }\n    }\n    \n    override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n        menuInflater.inflate(R.menu.dashboard_menu, menu)\n        return true\n    }\n    \n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            R.id.action_profile -> {\n                startActivity(Intent(this, ProfileActivity::class.java))\n                true\n            }\n            R.id.action_settings -> {\n                // TODO: Open settings\n                true\n            }\n            else -> super.onOptionsItemSelected(item)\n        }\n    }\n}\n","size_bytes":3472},"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/Operation.kt":{"content":"package com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(\n    tableName = \"operations\",\n    foreignKeys = [\n        ForeignKey(\n            entity = Event::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"eventId\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(\"eventId\")]\n)\ndata class Operation(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val eventId: Long, // R√©f√©rence √† l'√©v√©nement parent\n    val nom: String,\n    val type: String, // ADHESION, COTISATION_EXCEPTIONNELLE, FONDS_CAISSE\n    val montantCible: Double,\n    val dateDebut: Long,\n    val dateFin: Long? = null,\n    val statut: String = \"En cours\", // \"En cours\", \"Termin√©\", \"Cl√¥tur√©\"\n    val description: String? = null,\n    val createdAt: Long = System.currentTimeMillis()\n)\n","size_bytes":940},"AndroidProjects/gradle/libs.versions.toml":{"content":"[versions]\nagp = \"8.13.0\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.10.1\"\njunit = \"4.13.2\"\njunitVersion = \"1.1.5\"\nespressoCore = \"3.5.1\"\nappcompat = \"1.6.1\"\nmaterial = \"1.10.0\"\nactivity = \"1.8.0\"\nconstraintlayout = \"2.1.4\"\nroom = \"2.6.1\"\nlifecycle = \"2.7.0\"\ncoroutines = \"1.7.3\"\nksp = \"2.0.21-1.0.28\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nandroidx-activity = { group = \"androidx.activity\", name = \"activity\", version.ref = \"activity\" }\nandroidx-constraintlayout = { group = \"androidx.constraintlayout\", name = \"constraintlayout\", version.ref = \"constraintlayout\" }\nandroidx-room-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nandroidx-room-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nandroidx-room-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\nandroidx-lifecycle-viewmodel-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-viewmodel-ktx\", version.ref = \"lifecycle\" }\nandroidx-lifecycle-livedata-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-livedata-ktx\", version.ref = \"lifecycle\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycle\" }\nkotlinx-coroutines-android = { group = \"org.jetbrains.kotlinx\", name = \"kotlinx-coroutines-android\", version.ref = \"coroutines\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-ksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n\n","size_bytes":2134},"replit.md":{"content":"# Android Project - MUSEP50\n\n## Overview\nThis is a native Android application written in Kotlin for financial operations and transaction tracking (appears to be for a microfinance institution). The app includes:\n- User authentication (login/register)\n- Operations management\n- Payment tracking\n- Dashboard with financial data\n- Profile management\n\n## Project Structure\n- **Build System**: Gradle with Kotlin DSL\n- **Language**: Kotlin\n- **Architecture**: MVVM pattern with Room database\n- **Key Libraries**:\n  - Room (database)\n  - Lifecycle components\n  - Coroutines\n  - Material Design components\n\n## Important Note\n**This project cannot run on Replit** because it is a native Android application that requires:\n- Android SDK\n- Android emulator or physical device\n- Android Studio or similar IDE\n\nReplit does not support native Android development. Replit only supports React Native/Expo for mobile development.\n\n## Development Environment\nTo develop this app, you need:\n1. Download Android Studio\n2. Open this project in Android Studio\n3. Build and run on an emulator or connected Android device\n\n## Project Status\n- Import completed on October 05, 2025\n- Project files verified and intact\n- **XML Build Errors Fixed**: Corrected 4 layout XML files that had blank lines before the XML declaration\n- **Kotlin Compilation Errors Fixed**: Fixed type mismatches and coroutine issues\n- **Option A - Cycle de base**: ‚úÖ COMPL√âT√â\n  - ‚úÖ Ajout de paiements via dialog\n  - ‚úÖ Affichage des paiements avec noms des payeurs\n  - ‚úÖ Statistiques en temps r√©el (montant cibl√©/collect√©/restant)\n  - ‚úÖ Recherche et filtrage des paiements\n- **Option B - Publication et Export**: ‚úÖ COMPL√âT√â\n  - ‚úÖ G√©n√©ration de liste format√©e (texte avec statistiques)\n  - ‚úÖ Partage WhatsApp en un clic\n  - ‚úÖ Partage vers autres applications\n  - ‚úÖ Copie dans le presse-papiers\n  - ‚úÖ Export CSV avec toutes les donn√©es\n- **Option C - Retardataires**: ‚úÖ COMPL√âT√â\n  - ‚úÖ D√©tection automatique des membres n'ayant pas pay√©\n  - ‚úÖ Affichage avec s√©lection multiple\n  - ‚úÖ Messages de rappel personnalis√©s\n  - ‚úÖ Envoi individuel ou group√© via WhatsApp\n  - ‚úÖ Bouton d'acc√®s dans les d√©tails de l'op√©ration\n\n## üîÑ Architecture Refactoring - Hi√©rarchie √âv√©nements (October 12, 2025)\n**Nouvelle hi√©rarchie de donn√©es : √âv√©nements ‚Üí Op√©rations ‚Üí Paiements**\n\n### Changements majeurs :\n- **Nouvelle entit√© Event** : Les op√©rations sont maintenant organis√©es sous des √©v√©nements\n- **Relation Event-Operation** : Chaque op√©ration appartient √† un √©v√©nement (cl√© √©trang√®re eventId)\n- **Dashboard redesign√©** : Affiche maintenant les √©v√©nements au lieu des op√©rations directement\n- **Navigation am√©lior√©e** : \n  - Dashboard liste les √©v√©nements\n  - Cliquer sur un √©v√©nement ‚Üí affiche ses op√©rations (EventOperationsActivity)\n  - Cliquer sur une op√©ration ‚Üí affiche ses d√©tails et paiements\n\n### Nouveaux composants cr√©√©s :\n1. **Base de donn√©es** :\n   - `Event.kt` - Nouvelle entit√© pour les √©v√©nements\n   - `EventDao.kt` - DAO pour les requ√™tes √©v√©nements\n   - `AppDatabase` - Version 3 avec migration\n\n2. **Couche donn√©es** :\n   - Repository mis √† jour avec m√©thodes Event\n   - `EventViewModel.kt` - ViewModel pour g√©rer les √©v√©nements\n\n3. **Interface utilisateur** :\n   - `item_event.xml` - Layout pour afficher un √©v√©nement\n   - `EventAdapter.kt` - Adapter pour la liste des √©v√©nements\n   - `DashboardActivity` - Modifi√© pour afficher les √©v√©nements\n   - `activity_event_operations.xml` - Layout pour les op√©rations d'un √©v√©nement\n   - `EventOperationsActivity.kt` - Activit√© pour afficher les op√©rations d'un √©v√©nement\n   - `activity_new_event.xml` - Layout pour cr√©er un √©v√©nement\n   - `NewEventActivity.kt` - Activit√© pour cr√©er un nouvel √©v√©nement\n   - `NewOperationActivity` - Mis √† jour pour accepter eventId\n\n### Notes importantes :\n- **Migration de base de donn√©es** : Version 3 avec migration propre (MIGRATION_2_3)\n  - ‚úÖ Les donn√©es existantes sont PR√âSERV√âES lors de la mise √† jour\n  - Toutes les op√©rations existantes sont automatiquement assign√©es √† un √©v√©nement par d√©faut \"√âv√©nement historique\" (id=1, statut='Archiv√©')\n  - La migration cr√©e la table events, migre les op√©rations avec eventId, et pr√©serve tous les paiements\n- **Flux de travail** :\n  1. Cr√©er un √©v√©nement (ex: \"Assembl√©e G√©n√©rale 2024\")\n  2. Ajouter des op√©rations √† l'√©v√©nement\n  3. G√©rer les paiements pour chaque op√©ration\n\n## üéâ √âtat du Projet\nToutes les fonctionnalit√©s demand√©es ont √©t√© impl√©ment√©es avec succ√®s. La nouvelle architecture hi√©rarchique permet une meilleure organisation des op√©rations par √©v√©nement. L'application est pr√™te pour compilation et test dans Android Studio.\n","size_bytes":4802},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/PaiementDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.Paiement\n\n@Dao\ninterface PaiementDao {\n    @Query(\"SELECT * FROM paiements ORDER BY datePaiement DESC\")\n    fun getAllPaiements(): LiveData<List<Paiement>>\n    \n    @Query(\"SELECT * FROM paiements WHERE operationId = :operationId ORDER BY datePaiement DESC\")\n    fun getPaiementsByOperation(operationId: Long): LiveData<List<Paiement>>\n\n    @Query(\"SELECT SUM(montant) FROM paiements WHERE operationId = :operationId\")\n    suspend fun getTotalByOperation(operationId: Long): Double?\n    \n    @Query(\"SELECT COUNT(*) FROM paiements WHERE operationId = :operationId\")\n    suspend fun getCountByOperation(operationId: Long): Int\n\n    @Query(\"\"\"\n        SELECT paiements.*, payers.nom as payerName, payers.contact as payerContact \n        FROM paiements \n        INNER JOIN payers ON paiements.payerId = payers.id \n        WHERE paiements.operationId = :operationId \n        ORDER BY paiements.datePaiement DESC\n    \"\"\")\n    fun getPaiementsWithPayerByOperation(operationId: Long): LiveData<List<PaiementWithPayer>>\n\n    @Insert(onConflict = OnConflictStrategy.ABORT)\n    suspend fun insert(paiement: Paiement): Long\n\n    @Update\n    suspend fun update(paiement: Paiement)\n\n    @Delete\n    suspend fun delete(paiement: Paiement)\n}","size_bytes":1363},"AndroidProjects/app/src/main/java/com/example/musep50/ui/adapter/PaymentAdapter.kt":{"content":"package com.example.musep50.ui.adapter\n\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.DiffUtil\nimport androidx.recyclerview.widget.ListAdapter\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.musep50.data.dao.PaiementWithPayer\nimport com.example.musep50.databinding.ItemPaymentBinding\nimport java.text.NumberFormat\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nclass PaymentAdapter : ListAdapter<com.example.musep50.data.dao.PaiementWithPayer, PaymentAdapter.PaymentViewHolder>(PaymentDiffCallback()) {\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PaymentViewHolder {\n        val binding = ItemPaymentBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return PaymentViewHolder(binding)\n    }\n\n    override fun onBindViewHolder(holder: PaymentViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n\n    class PaymentViewHolder(\n        private val binding: ItemPaymentBinding\n    ) : RecyclerView.ViewHolder(binding.root) {\n\n        private val dateFormat = SimpleDateFormat(\"d MMM yyyy\", Locale.FRANCE)\n        private val formatter = NumberFormat.getNumberInstance(Locale.FRANCE)\n\n        fun bind(paiementWithPayer: com.example.musep50.data.dao.PaiementWithPayer) {\n            binding.payerName.text = paiementWithPayer.payerName\n            binding.montant.text = \"${formatter.format(paiementWithPayer.paiement.montant)} FCFA\"\n            binding.datePaiement.text = dateFormat.format(paiementWithPayer.paiement.datePaiement)\n            binding.methode.text = paiementWithPayer.paiement.methodePaiement\n\n            if (paiementWithPayer.paiement.commentaire.isNullOrBlank()) {\n                binding.commentaire.visibility = View.GONE\n            } else {\n                binding.commentaire.visibility = View.VISIBLE\n                binding.commentaire.text = paiementWithPayer.paiement.commentaire\n            }\n        }\n    }\n}\n\nclass PaymentDiffCallback : DiffUtil.ItemCallback<com.example.musep50.data.dao.PaiementWithPayer>() {\n    override fun areItemsTheSame(oldItem: com.example.musep50.data.dao.PaiementWithPayer, newItem: com.example.musep50.data.dao.PaiementWithPayer): Boolean {\n        return oldItem.paiement.id == newItem.paiement.id\n    }\n\n    override fun areContentsTheSame(oldItem: com.example.musep50.data.dao.PaiementWithPayer, newItem: com.example.musep50.data.dao.PaiementWithPayer): Boolean {\n        return oldItem == newItem\n    }\n}","size_bytes":2591},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/UserDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.User\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): LiveData<List<User>>\n\n    @Query(\"SELECT * FROM users WHERE id = :id\")\n    suspend fun getUserById(id: Long): User?\n\n    @Query(\"SELECT * FROM users WHERE email = :email\")\n    suspend fun getUserByEmail(email: String): User?\n\n    @Query(\"SELECT * FROM users WHERE email = :email AND pin = :pin\")\n    suspend fun verifyCredentials(email: String, pin: String): User?\n\n    @Insert(onConflict = OnConflictStrategy.ABORT)\n    suspend fun insert(user: User): Long\n\n    @Update\n    suspend fun update(user: User)\n\n    @Delete\n    suspend fun delete(user: User)\n\n    @Query(\"UPDATE users SET pin = :newPin WHERE id = :userId\")\n    suspend fun updatePin(userId: Long, newPin: String)\n}","size_bytes":901},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/PayerDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.Payer\n\n@Dao\ninterface PayerDao {\n    @Query(\"SELECT * FROM payers ORDER BY nom ASC\")\n    fun getAllPayers(): LiveData<List<Payer>>\n\n    @Query(\"SELECT * FROM payers ORDER BY nom ASC\")\n    suspend fun getAllPayersSync(): List<Payer>\n\n    @Query(\"SELECT * FROM payers WHERE id = :id\")\n    suspend fun getPayerById(id: Long): Payer?\n\n    @Query(\"SELECT * FROM payers WHERE eventId = :eventId ORDER BY nom ASC\")\n    fun getPayersByEvent(eventId: Long): LiveData<List<Payer>>\n\n    @Query(\"SELECT * FROM payers WHERE eventId = :eventId ORDER BY nom ASC\")\n    suspend fun getPayersByEventSync(eventId: Long): List<Payer>\n\n    @Query(\"SELECT * FROM payers WHERE nom LIKE '%' || :searchQuery || '%' ORDER BY nom ASC\")\n    fun searchPayers(searchQuery: String): LiveData<List<Payer>>\n\n    @Query(\"SELECT * FROM payers WHERE eventId = :eventId AND nom LIKE '%' || :searchQuery || '%' ORDER BY nom ASC\")\n    fun searchPayersByEvent(eventId: Long, searchQuery: String): LiveData<List<Payer>>\n\n    @Insert(onConflict = OnConflictStrategy.ABORT)\n    suspend fun insert(payer: Payer): Long\n\n    @Update\n    suspend fun update(payer: Payer)\n\n    @Delete\n    suspend fun delete(payer: Payer)\n}","size_bytes":1312},"AndroidProjects/app/src/main/java/com/example/musep50/data/Repository.kt":{"content":"package com.example.musep50.data\n\nimport androidx.lifecycle.LiveData\nimport com.example.musep50.data.dao.PaiementWithPayer\nimport com.example.musep50.data.entities.*\n\nclass Repository(private val database: AppDatabase) {\n\n    // Event methods\n    fun getAllEvents(): LiveData<List<Event>> = database.eventDao().getAllEvents()\n\n    suspend fun getEventById(eventId: Long): Event? {\n        return database.eventDao().getEventById(eventId)\n    }\n\n    suspend fun insertEvent(event: Event): Long = database.eventDao().insert(event)\n\n    suspend fun updateEvent(event: Event) = database.eventDao().update(event)\n\n    suspend fun deleteEvent(event: Event) = database.eventDao().delete(event)\n\n    suspend fun archiveEvent(eventId: Long) = database.eventDao().archiveEvent(eventId)\n\n    // Operation methods\n    fun getAllOperations(): LiveData<List<Operation>> = database.operationDao().getAllOperations()\n\n    fun getOperationsByType(type: String): LiveData<List<Operation>> =\n        database.operationDao().getOperationsByType(type)\n\n    suspend fun getOperationById(id: Long): Operation? =\n        database.operationDao().getOperationById(id)\n\n    fun getOperationsByEtat(etat: String): LiveData<List<Operation>> =\n        database.operationDao().getOperationsByEtat(etat)\n\n    fun getOperationsByEvent(eventId: Long): LiveData<List<Operation>> =\n        database.operationDao().getOperationsByEvent(eventId)\n\n    suspend fun insertOperation(operation: Operation): Long =\n        database.operationDao().insert(operation)\n\n    suspend fun updateOperation(operation: Operation) =\n        database.operationDao().update(operation)\n\n    suspend fun deleteOperation(operation: Operation) =\n        database.operationDao().delete(operation)\n\n    // Payer methods\n    fun getAllPayers(): LiveData<List<Payer>> = database.payerDao().getAllPayers()\n\n    suspend fun getAllPayersSync(): List<Payer> {\n        return database.payerDao().getAllPayersSync()\n    }\n\n    suspend fun getPayerById(id: Long): Payer? = database.payerDao().getPayerById(id)\n\n    fun searchPayers(query: String): LiveData<List<Payer>> =\n        database.payerDao().searchPayers(query)\n\n    suspend fun insertPayer(payer: Payer): Long = database.payerDao().insert(payer)\n\n    suspend fun updatePayer(payer: Payer) = database.payerDao().update(payer)\n\n    suspend fun deletePayer(payer: Payer) = database.payerDao().delete(payer)\n\n    // Paiement methods\n    fun getAllPaiements(): LiveData<List<Paiement>> {\n        return database.paiementDao().getAllPaiements()\n    }\n\n    fun getPaiementsByOperation(operationId: Long): LiveData<List<Paiement>> =\n        database.paiementDao().getPaiementsByOperation(operationId)\n\n    fun getPaiementsWithPayerByOperation(operationId: Long): LiveData<List<PaiementWithPayer>> =\n        database.paiementDao().getPaiementsWithPayerByOperation(operationId)\n\n    suspend fun getTotalByOperation(operationId: Long): Double? =\n        database.paiementDao().getTotalByOperation(operationId)\n\n    suspend fun getCountByOperation(operationId: Long): Int =\n        database.paiementDao().getCountByOperation(operationId)\n\n    suspend fun insertPaiement(paiement: Paiement): Long =\n        database.paiementDao().insert(paiement)\n\n    suspend fun updatePaiement(paiement: Paiement) =\n        database.paiementDao().update(paiement)\n\n    suspend fun deletePaiement(paiement: Paiement) =\n        database.paiementDao().delete(paiement)\n\n    // User methods\n    suspend fun getUserByEmail(email: String): User? =\n        database.userDao().getUserByEmail(email)\n\n    suspend fun getUserById(id: Long): User? =\n        database.userDao().getUserById(id)\n\n    suspend fun insertUser(user: User): Long =\n        database.userDao().insert(user)\n\n    fun getAllUsers(): LiveData<List<User>> =\n        database.userDao().getAllUsers()\n}","size_bytes":3818},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/DashboardViewModel.kt":{"content":"package com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Operation\nimport kotlinx.coroutines.launch\n\nclass DashboardViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    val allOperations: LiveData<List<Operation>> = repository.getAllOperations()\n\n    private val _operationStats = MutableLiveData<Map<Long, OperationStats>>()\n    val operationStats: LiveData<Map<Long, OperationStats>> = _operationStats\n\n    fun loadOperationStats(operationIds: List<Long>) {\n        viewModelScope.launch {\n            val stats = mutableMapOf<Long, OperationStats>()\n            operationIds.forEach { id ->\n                val total = repository.getTotalByOperation(id) ?: 0.0\n                val count = repository.getCountByOperation(id)\n                val operation = repository.getOperationById(id)\n                operation?.let {\n                    stats[id] = OperationStats(\n                        montantCollecte = total,\n                        nombrePaiements = count,\n                        montantCible = it.montantCible\n                    )\n                }\n            }\n            _operationStats.value = stats\n        }\n    }\n}\n\ndata class OperationStats(\n    val montantCollecte: Double,\n    val nombrePaiements: Int,\n    val montantCible: Double\n) {\n    val montantRestant: Double\n        get() = montantCible - montantCollecte\n\n    val pourcentage: Int\n        get() = if (montantCible > 0) ((montantCollecte / montantCible) * 100).toInt() else 0\n}","size_bytes":1876},"AndroidProjects/app/src/main/java/com/example/musep50/ui/AddPayerDialog.kt":{"content":"\npackage com.example.musep50.ui\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Toast\nimport androidx.fragment.app.DialogFragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport com.example.musep50.data.entities.Payer\nimport com.example.musep50.databinding.DialogAddPayerBinding\nimport com.example.musep50.viewmodel.PayerViewModel\nimport kotlinx.coroutines.launch\n\nclass AddPayerDialog(\n    private val onPayerAdded: () -> Unit\n) : DialogFragment() {\n\n    private var _binding: DialogAddPayerBinding? = null\n    private val binding get() = _binding!!\n    private val payerViewModel: PayerViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = DialogAddPayerBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        dialog?.window?.setBackgroundDrawableResource(android.R.color.transparent)\n\n        setupButtons()\n    }\n\n    private fun setupButtons() {\n        binding.btnCancel.setOnClickListener {\n            dismiss()\n        }\n\n        binding.btnSave.setOnClickListener {\n            if (validateInputs()) {\n                savePayer()\n            }\n        }\n    }\n\n    private fun validateInputs(): Boolean {\n        val payerName = binding.payerNameInput.text.toString()\n        if (payerName.isBlank()) {\n            binding.payerNameInputLayout.error = \"Le nom du payeur est requis\"\n            return false\n        }\n        binding.payerNameInputLayout.error = null\n        return true\n    }\n\n    private fun savePayer() {\n        val payerName = binding.payerNameInput.text.toString()\n        val contact = binding.payerContactInput.text?.toString()\n        val note = binding.payerNoteInput.text?.toString()\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            val newPayer = Payer(\n                nom = payerName,\n                contact = contact,\n                note = note\n            )\n\n            try {\n                payerViewModel.insertPayer(newPayer)\n                Toast.makeText(requireContext(), \"Payeur ajout√© avec succ√®s\", Toast.LENGTH_SHORT).show()\n                onPayerAdded()\n                dismiss()\n            } catch (e: Exception) {\n                Toast.makeText(requireContext(), \"Erreur: ${e.message}\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n\n    companion object {\n        const val TAG = \"AddPayerDialog\"\n    }\n}","size_bytes":2816},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/AuthViewModel.kt":{"content":"package com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.User\nimport kotlinx.coroutines.launch\n\nclass AuthViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    private val _loginResult = MutableLiveData<LoginResult>()\n    val loginResult: LiveData<LoginResult> = _loginResult\n\n    private val _registerResult = MutableLiveData<RegisterResult>()\n    val registerResult: LiveData<RegisterResult> = _registerResult\n    \n    private val _currentUser = MutableLiveData<User?>()\n    val currentUser: LiveData<User?> = _currentUser\n\n    fun login(email: String, pin: String) {\n        viewModelScope.launch {\n            val user = repository.getUserByEmail(email)\n            if (user != null && user.pin == pin) {\n                _loginResult.value = LoginResult.Success(user)\n            } else {\n                _loginResult.value = LoginResult.Error(\"Email ou PIN incorrect\")\n            }\n        }\n    }\n\n    fun register(nom: String, email: String, telephone: String?, organisation: String?, pin: String) {\n        viewModelScope.launch {\n            try {\n                val existingUser = repository.getUserByEmail(email)\n                if (existingUser != null) {\n                    _registerResult.value = RegisterResult.Error(\"Un compte avec cet email existe d√©j√†\")\n                    return@launch\n                }\n\n                val user = User(\n                    nom = nom,\n                    email = email,\n                    telephone = telephone,\n                    organisation = organisation,\n                    pin = pin\n                )\n                val userId = repository.insertUser(user)\n                val createdUser = repository.getUserById(userId)\n                _registerResult.value = RegisterResult.Success(createdUser!!)\n            } catch (e: Exception) {\n                _registerResult.value = RegisterResult.Error(\"Erreur lors de la cr√©ation du compte: ${e.message}\")\n            }\n        }\n    }\n\n    fun insertUser(user: User, onSuccess: () -> Unit, onError: (String) -> Unit) {\n        viewModelScope.launch {\n            try {\n                repository.insertUser(user)\n                onSuccess()\n            } catch (e: Exception) {\n                onError(e.message ?: \"Erreur lors de la cr√©ation de l'utilisateur\")\n            }\n        }\n    }\n\n    fun getAllUsers(): LiveData<List<User>> = repository.getAllUsers()\n\n    suspend fun getUserById(id: Long): User? = repository.getUserById(id)\n    \n    fun loadUserById(userId: Long) {\n        viewModelScope.launch {\n            val user = repository.getUserById(userId)\n            _currentUser.value = user\n        }\n    }\n}\n\nsealed class LoginResult {\n    data class Success(val user: User) : LoginResult()\n    data class Error(val message: String) : LoginResult()\n}\n\nsealed class RegisterResult {\n    data class Success(val user: User) : RegisterResult()\n    data class Error(val message: String) : RegisterResult()\n}","size_bytes":3348},"AndroidProjects/app/src/main/java/com/example/musep50/ui/RegisterActivity.kt":{"content":"\npackage com.example.musep50.ui\n\nimport android.os.Bundle\nimport android.widget.Toast\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport com.example.musep50.databinding.ActivityRegisterBinding\nimport com.example.musep50.viewmodel.AuthViewModel\nimport com.example.musep50.viewmodel.RegisterResult\n\nclass RegisterActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityRegisterBinding\n    private val viewModel: AuthViewModel by viewModels()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityRegisterBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        setupUI()\n        observeViewModel()\n    }\n    \n    private fun setupUI() {\n        binding.registerButton.setOnClickListener {\n            val nom = binding.nomInput.text.toString()\n            val email = binding.emailInput.text.toString()\n            val telephone = binding.telephoneInput.text?.toString()\n            val organisation = binding.organisationInput.text?.toString()\n            val pin = binding.pinInput.text.toString()\n            \n            if (validateInputs(nom, email, telephone, organisation, pin)) {\n                viewModel.register(nom, email, telephone, organisation, pin)\n            }\n        }\n        \n        binding.loginButton.setOnClickListener {\n            finish()\n        }\n    }\n    \n    private fun validateInputs(nom: String, email: String, telephone: String?, organisation: String?, pin: String): Boolean {\n        if (nom.isBlank() || email.isBlank() || pin.isBlank()) {\n            Toast.makeText(this, \"Veuillez remplir tous les champs obligatoires\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n        \n        if (pin.length != 4 || !pin.all { it.isDigit() }) {\n            Toast.makeText(this, \"Le code PIN doit √™tre compos√© de 4 chiffres\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n        \n        return true\n    }\n    \n    private fun observeViewModel() {\n        viewModel.registerResult.observe(this) { result ->\n            when (result) {\n                is RegisterResult.Success -> {\n                    Toast.makeText(this, \"Inscription r√©ussie\", Toast.LENGTH_SHORT).show()\n                    finish()\n                }\n                is RegisterResult.Error -> {\n                    Toast.makeText(this, result.message, Toast.LENGTH_SHORT).show()\n                }\n            }\n        }\n    }\n}\n","size_bytes":2530},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/ParametreDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.Parametre\n\n@Dao\ninterface ParametreDao {\n    @Query(\"SELECT * FROM parametres\")\n    fun getAllParametres(): LiveData<List<Parametre>>\n    \n    @Query(\"SELECT * FROM parametres WHERE cle = :key\")\n    suspend fun getParametre(key: String): Parametre?\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(parametre: Parametre)\n    \n    @Query(\"UPDATE parametres SET valeur = :value, updatedAt = :timestamp WHERE cle = :key\")\n    suspend fun updateValue(key: String, value: String, timestamp: Long = System.currentTimeMillis())\n    \n    @Delete\n    suspend fun delete(parametre: Parametre)\n}\n","size_bytes":753},"AndroidProjects/app/src/main/java/com/example/musep50/data/dao/EventDao.kt":{"content":"package com.example.musep50.data.dao\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\nimport com.example.musep50.data.entities.Event\n\n@Dao\ninterface EventDao {\n    @Query(\"SELECT * FROM events ORDER BY createdAt DESC\")\n    fun getAllEvents(): LiveData<List<Event>>\n\n    @Query(\"SELECT * FROM events WHERE id = :eventId\")\n    suspend fun getEventById(eventId: Long): Event?\n\n    @Query(\"SELECT * FROM events WHERE id = :id\")\n    fun getEventByIdLive(id: Long): LiveData<Event?>\n\n    @Query(\"SELECT * FROM events WHERE statut = 'En cours' ORDER BY createdAt DESC\")\n    fun getActiveEvents(): LiveData<List<Event>>\n\n    @Query(\"SELECT * FROM events WHERE statut = :statut ORDER BY dateDebut DESC\")\n    fun getEventsByState(statut: String): LiveData<List<Event>>\n\n    @Insert(onConflict = OnConflictStrategy.ABORT)\n    suspend fun insert(event: Event): Long\n\n    @Update\n    suspend fun update(event: Event)\n\n    @Delete\n    suspend fun delete(event: Event)\n\n    @Query(\"UPDATE events SET statut = 'Archiv√©' WHERE id = :eventId\")\n    suspend fun archiveEvent(eventId: Long)\n}","size_bytes":1082},"AndroidProjects/app/src/main/java/com/example/musep50/data/entities/Event.kt":{"content":"package com.example.musep50.data.entities\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"events\")\ndata class Event(\n    @PrimaryKey(autoGenerate = true)\n    val id: Long = 0,\n    val nom: String,\n    val description: String? = null,\n    val dateDebut: Long,\n    val dateFin: Long? = null,\n    val statut: String = \"En cours\", // \"En cours\", \"Termin√©\", \"Archiv√©\"\n    val createdAt: Long = System.currentTimeMillis()\n)\n","size_bytes":455},"AndroidProjects/app/src/main/java/com/example/musep50/ui/EventOperationsActivity.kt":{"content":"\npackage com.example.musep50.ui\n\nimport android.content.Intent\nimport android.os.Bundle\nimport android.view.View\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.musep50.R\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Operation\nimport com.example.musep50.databinding.ActivityEventOperationsBinding\nimport com.example.musep50.ui.adapter.OperationAdapter\nimport com.example.musep50.viewmodel.DashboardViewModel\nimport com.example.musep50.viewmodel.EventViewModel\nimport kotlinx.coroutines.launch\n\nclass EventOperationsActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityEventOperationsBinding\n    private lateinit var repository: Repository\n    private lateinit var eventViewModel: EventViewModel\n    private lateinit var adapter: OperationAdapter\n    private var eventId: Long = -1\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityEventOperationsBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        eventId = intent.getLongExtra(\"event_id\", -1)\n        \n        if (eventId == -1L) {\n            finish()\n            return\n        }\n        \n        repository = Repository(AppDatabase.getDatabase(this))\n        eventViewModel = ViewModelProvider(this)[EventViewModel::class.java]\n        \n        setupToolbar()\n        setupRecyclerView()\n        setupFab()\n        loadEventData()\n        observeOperations()\n    }\n    \n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n    \n    private fun setupRecyclerView() {\n        adapter = OperationAdapter { operation ->\n            val intent = Intent(this, OperationDetailsActivity::class.java)\n            intent.putExtra(\"operation_id\", operation.id)\n            startActivity(intent)\n        }\n        \n        binding.operationsRecyclerView.layoutManager = LinearLayoutManager(this)\n        binding.operationsRecyclerView.adapter = adapter\n    }\n    \n    private fun setupFab() {\n        binding.fabNewOperation.setOnClickListener {\n            val intent = Intent(this, NewOperationActivity::class.java)\n            intent.putExtra(\"event_id\", eventId)\n            startActivity(intent)\n        }\n    }\n    \n    private fun loadEventData() {\n        lifecycleScope.launch {\n            val event = repository.getEventById(eventId)\n            event?.let {\n                binding.eventName.text = it.nom\n                binding.eventDescription.text = it.description\n            }\n        }\n    }\n    \n    private fun observeOperations() {\n        eventViewModel.getOperationsByEvent(eventId).observe(this) { operations ->\n            if (operations.isEmpty()) {\n                binding.emptyStateLayout.visibility = View.VISIBLE\n                binding.operationsRecyclerView.visibility = View.GONE\n            } else {\n                binding.emptyStateLayout.visibility = View.GONE\n                binding.operationsRecyclerView.visibility = View.VISIBLE\n                adapter.submitList(operations)\n            }\n        }\n    }\n    \n    override fun onResume() {\n        super.onResume()\n        loadEventData()\n    }\n}\n","size_bytes":3537},"AndroidProjects/app/src/main/java/com/example/musep50/viewmodel/EventViewModel.kt":{"content":"package com.example.musep50.viewmodel\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.viewModelScope\nimport com.example.musep50.data.AppDatabase\nimport com.example.musep50.data.Repository\nimport com.example.musep50.data.entities.Event\nimport kotlinx.coroutines.launch\n\nclass EventViewModel(application: Application) : AndroidViewModel(application) {\n    private val repository: Repository = Repository(AppDatabase.getDatabase(application))\n\n    val allEvents: LiveData<List<Event>> = repository.getAllEvents()\n\n    fun getOperationsByEvent(eventId: Long) = repository.getOperationsByEvent(eventId)\n\n    suspend fun insertEvent(event: Event): Long {\n        return repository.insertEvent(event)\n    }\n\n    suspend fun updateEvent(event: Event) {\n        repository.updateEvent(event)\n    }\n\n    suspend fun deleteEvent(event: Event) {\n        repository.deleteEvent(event)\n    }\n}\n","size_bytes":968},"AndroidProjects/app/src/main/java/com/example/musep50/ui/NewEventActivity.kt":{"content":"package com.example.musep50.ui\n\nimport android.app.DatePickerDialog\nimport android.os.Bundle\nimport android.widget.ArrayAdapter\nimport android.widget.Toast\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport com.example.musep50.data.entities.Event\nimport com.example.musep50.databinding.ActivityNewEventBinding\nimport com.example.musep50.viewmodel.EventViewModel\nimport kotlinx.coroutines.launch\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nclass NewEventActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityNewEventBinding\n    private val viewModel: EventViewModel by viewModels()\n    private val calendar = Calendar.getInstance()\n    private val dateFormat = SimpleDateFormat(\"dd/MM/yyyy\", Locale.FRANCE)\n    private var dateDebut: Date? = null\n    private var dateFin: Date? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityNewEventBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        setupToolbar()\n        setupStatusDropdown()\n        setupDatePickers()\n        setupCreateButton()\n    }\n\n    private fun setupToolbar() {\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        binding.toolbar.setNavigationOnClickListener {\n            finish()\n        }\n    }\n\n    private fun setupStatusDropdown() {\n        val statusOptions = arrayOf(\"En cours\", \"Termin√©\", \"Planifi√©\")\n        val adapter = ArrayAdapter(this, android.R.layout.simple_dropdown_item_1line, statusOptions)\n        binding.statusInput.setAdapter(adapter)\n    }\n\n    private fun setupDatePickers() {\n        binding.startDateInput.setOnClickListener {\n            showDatePicker { date ->\n                dateDebut = date\n                binding.startDateInput.setText(dateFormat.format(date))\n            }\n        }\n\n        binding.endDateInput.setOnClickListener {\n            showDatePicker { date ->\n                dateFin = date\n                binding.endDateInput.setText(dateFormat.format(date))\n            }\n        }\n    }\n\n    private fun showDatePicker(onDateSelected: (Date) -> Unit) {\n        val datePickerDialog = DatePickerDialog(\n            this,\n            { _, year, month, dayOfMonth ->\n                calendar.set(year, month, dayOfMonth)\n                onDateSelected(calendar.time)\n            },\n            calendar.get(Calendar.YEAR),\n            calendar.get(Calendar.MONTH),\n            calendar.get(Calendar.DAY_OF_MONTH)\n        )\n        datePickerDialog.show()\n    }\n\n    private fun setupCreateButton() {\n        binding.btnCreateEvent.setOnClickListener {\n            if (validateInputs()) {\n                createEvent()\n            }\n        }\n    }\n\n    private fun createEvent() {\n        val nom = binding.nameInput.text.toString()\n        val description = binding.descriptionInput.text.toString()\n        val lieu = binding.lieuInput.text.toString()\n        val status = binding.statusInput.text.toString()\n\n        val event = Event(\n            nom = nom,\n            description = description.ifEmpty { null },\n            dateDebut = dateDebut!!.time,\n            dateFin = dateFin?.time,\n            statut = status.ifEmpty { \"En cours\" }\n        )\n\n        lifecycleScope.launch {\n            try {\n                viewModel.insertEvent(event)\n                Toast.makeText(this@NewEventActivity, \"√âv√©nement cr√©√© avec succ√®s\", Toast.LENGTH_SHORT).show()\n                finish()\n            } catch (e: Exception) {\n                Toast.makeText(this@NewEventActivity, \"Erreur: ${e.message}\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    private fun validateInputs(): Boolean {\n        val nom = binding.nameInput.text.toString()\n\n        if (nom.isBlank()) {\n            Toast.makeText(this, \"Veuillez entrer un nom pour l'√©v√©nement\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        if (dateDebut == null) {\n            Toast.makeText(this, \"Veuillez s√©lectionner la date de d√©but\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        if (dateFin != null && dateFin!!.before(dateDebut)) {\n            Toast.makeText(this, \"La date de fin doit √™tre apr√®s la date de d√©but\", Toast.LENGTH_SHORT).show()\n            return false\n        }\n\n        return true\n    }\n}","size_bytes":4444},"AndroidProjects/app/src/main/java/com/example/musep50/ui/adapter/EventAdapter.kt":{"content":"package com.example.musep50.ui.adapter\n\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.DiffUtil\nimport androidx.recyclerview.widget.ListAdapter\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.musep50.data.entities.Event\nimport com.example.musep50.databinding.ItemEventBinding\nimport java.text.SimpleDateFormat\nimport java.util.Date\nimport java.util.Locale\n\nclass EventAdapter(\n    private val onItemClick: (Event) -> Unit\n) : ListAdapter<Event, EventAdapter.EventViewHolder>(EventDiffCallback()) {\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): EventViewHolder {\n        val binding = ItemEventBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return EventViewHolder(binding)\n    }\n\n    override fun onBindViewHolder(holder: EventViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n\n    inner class EventViewHolder(\n        private val binding: ItemEventBinding\n    ) : RecyclerView.ViewHolder(binding.root) {\n\n        fun bind(event: Event) {\n            binding.eventName.text = event.nom\n            binding.eventDescription.text = event.description ?: \"Aucune description\"\n            binding.statusChip.text = event.statut\n\n            val dateFormatter = SimpleDateFormat(\"dd/MM/yyyy\", Locale.FRANCE)\n            binding.eventStartDate.text = dateFormatter.format(Date(event.dateDebut))\n            \n            binding.operationCount.text = \"0\"\n\n            binding.root.setOnClickListener {\n                onItemClick(event)\n            }\n        }\n    }\n}\n\nclass EventDiffCallback : DiffUtil.ItemCallback<Event>() {\n    override fun areItemsTheSame(oldItem: Event, newItem: Event): Boolean {\n        return oldItem.id == newItem.id\n    }\n\n    override fun areContentsTheSame(oldItem: Event, newItem: Event): Boolean {\n        return oldItem == newItem\n    }\n}\n","size_bytes":1963},"AndroidProjects/app/src/main/java/com/example/musep50/ui/adapter/ParticipantAdapter.kt":{"content":"package com.example.musep50.ui.adapter\n\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.DiffUtil\nimport androidx.recyclerview.widget.ListAdapter\nimport androidx.recyclerview.widget.RecyclerView\nimport com.example.musep50.data.entities.Payer\nimport com.example.musep50.databinding.ItemParticipantBinding\n\nclass ParticipantAdapter(\n    private val onDeleteClick: (Payer) -> Unit\n) : ListAdapter<Payer, ParticipantAdapter.ParticipantViewHolder>(ParticipantDiffCallback()) {\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ParticipantViewHolder {\n        val binding = ItemParticipantBinding.inflate(\n            LayoutInflater.from(parent.context),\n            parent,\n            false\n        )\n        return ParticipantViewHolder(binding)\n    }\n\n    override fun onBindViewHolder(holder: ParticipantViewHolder, position: Int) {\n        holder.bind(getItem(position))\n    }\n\n    inner class ParticipantViewHolder(\n        private val binding: ItemParticipantBinding\n    ) : RecyclerView.ViewHolder(binding.root) {\n\n        fun bind(payer: Payer) {\n            binding.participantName.text = payer.nom\n            \n            if (payer.contact.isNullOrBlank()) {\n                binding.participantContact.visibility = View.GONE\n            } else {\n                binding.participantContact.visibility = View.VISIBLE\n                binding.participantContact.text = payer.contact\n            }\n\n            binding.btnDeleteParticipant.setOnClickListener {\n                onDeleteClick(payer)\n            }\n        }\n    }\n}\n\nclass ParticipantDiffCallback : DiffUtil.ItemCallback<Payer>() {\n    override fun areItemsTheSame(oldItem: Payer, newItem: Payer): Boolean {\n        return oldItem.id == newItem.id\n    }\n\n    override fun areContentsTheSame(oldItem: Payer, newItem: Payer): Boolean {\n        return oldItem == newItem\n    }\n}\n","size_bytes":1941},"AndroidProjects/app/src/main/java/com/example/musep50/ui/ManageParticipantsDialog.kt":{"content":"package com.example.musep50.ui\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Toast\nimport androidx.fragment.app.DialogFragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.musep50.data.entities.Payer\nimport com.example.musep50.databinding.DialogManageParticipantsBinding\nimport com.example.musep50.ui.adapter.ParticipantAdapter\nimport com.example.musep50.viewmodel.PayerViewModel\nimport kotlinx.coroutines.launch\n\nclass ManageParticipantsDialog(\n    private val eventId: Long,\n    private val eventName: String\n) : DialogFragment() {\n\n    private var _binding: DialogManageParticipantsBinding? = null\n    private val binding get() = _binding!!\n    private val payerViewModel: PayerViewModel by viewModels()\n    private lateinit var adapter: ParticipantAdapter\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = DialogManageParticipantsBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        dialog?.window?.setBackgroundDrawableResource(android.R.color.transparent)\n        dialog?.window?.setLayout(\n            ViewGroup.LayoutParams.MATCH_PARENT,\n            ViewGroup.LayoutParams.WRAP_CONTENT\n        )\n\n        binding.eventNameText.text = \"√âv√©nement: $eventName\"\n\n        setupRecyclerView()\n        setupButtons()\n        observeParticipants()\n    }\n\n    private fun setupRecyclerView() {\n        adapter = ParticipantAdapter { payer ->\n            deleteParticipant(payer)\n        }\n\n        binding.participantsRecyclerView.layoutManager = LinearLayoutManager(requireContext())\n        binding.participantsRecyclerView.adapter = adapter\n    }\n\n    private fun setupButtons() {\n        binding.btnAddParticipant.setOnClickListener {\n            if (validateInputs()) {\n                addParticipant()\n            }\n        }\n\n        binding.btnClose.setOnClickListener {\n            dismiss()\n        }\n    }\n\n    private fun observeParticipants() {\n        payerViewModel.getPayersByEvent(eventId).observe(viewLifecycleOwner) { participants ->\n            if (participants.isEmpty()) {\n                binding.participantsRecyclerView.visibility = View.GONE\n                binding.emptyStateText.visibility = View.VISIBLE\n            } else {\n                binding.participantsRecyclerView.visibility = View.VISIBLE\n                binding.emptyStateText.visibility = View.GONE\n                adapter.submitList(participants)\n            }\n        }\n    }\n\n    private fun validateInputs(): Boolean {\n        val participantName = binding.payerNameInput.text.toString()\n        if (participantName.isBlank()) {\n            binding.payerNameInputLayout.error = \"Le nom du participant est requis\"\n            return false\n        }\n        binding.payerNameInputLayout.error = null\n        return true\n    }\n\n    private fun addParticipant() {\n        val participantName = binding.payerNameInput.text.toString()\n        val contact = binding.payerContactInput.text?.toString()\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            val newParticipant = Payer(\n                eventId = eventId,\n                nom = participantName,\n                contact = contact\n            )\n\n            try {\n                payerViewModel.insertPayer(newParticipant)\n                Toast.makeText(requireContext(), \"Participant ajout√© avec succ√®s\", Toast.LENGTH_SHORT).show()\n                \n                binding.payerNameInput.text?.clear()\n                binding.payerContactInput.text?.clear()\n            } catch (e: Exception) {\n                Toast.makeText(requireContext(), \"Erreur: ${e.message}\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    private fun deleteParticipant(payer: Payer) {\n        viewLifecycleOwner.lifecycleScope.launch {\n            try {\n                payerViewModel.deletePayer(payer)\n                Toast.makeText(requireContext(), \"Participant supprim√©\", Toast.LENGTH_SHORT).show()\n            } catch (e: Exception) {\n                Toast.makeText(requireContext(), \"Erreur lors de la suppression: ${e.message}\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n\n    companion object {\n        const val TAG = \"ManageParticipantsDialog\"\n    }\n}\n","size_bytes":4709}},"version":2}